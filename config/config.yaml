# ==============================================================================
# SIXBTC MASTER CONFIGURATION
# ==============================================================================
# Last updated: 2025-12-20
# Version: 1.0.0
#
# IMPORTANT: All values in this file are REQUIRED - no fallback defaults!
# Missing or invalid config will cause system to crash at startup (Fast Fail)
# Sensitive credentials (API keys, passwords) go in .env, NOT here

system:
  name: "SixBTC"
  version: "1.0.0"
  execution_mode: hybrid  # sync, async, multiprocess, hybrid

# ==============================================================================
# GLOBAL TIMEFRAMES (used by downloader, generator, backtester, executor)
# ==============================================================================
timeframes: ['15m', '30m', '1h', '2h']

# ==============================================================================
# REGIME DETECTION (Unger Method)
# ==============================================================================
# Detects market regime (TREND vs REVERSAL) using breakout/reversal tests.
# Used by Unger Generator to create regime-coherent strategies.
# When enabled, downloader will also fetch the regime timeframe (1d).
regime:
  enabled: true
  timeframe: '1d'              # Timeframe for regime analysis (daily recommended)
  window_days: 90              # Days for breakout/reversal tests (balance: significance vs recency)

  # Classification thresholds
  trend_threshold: 0.6         # breakout/reversal ratio for TREND
  reversal_threshold: 0.6      # reversal/breakout ratio for REVERSAL
  min_strength: 0.5            # Below this -> MIXED regardless of ratio

  # Regime-aware generation settings
  generation:
    strategies_per_group: 10   # Strategies to generate per regime group

# ==============================================================================
# DIRECTORIES
# ==============================================================================
directories:
  data: data

# ==============================================================================
# DATABASE (PostgreSQL via Docker)
# ==============================================================================
database:
  # Connection settings (from .env)
  host: ${DB_HOST}
  port: ${DB_PORT}
  database: ${DB_NAME}
  user: ${DB_USER}
  password: ${DB_PASSWORD}

  pool:
    min_connections: 5
    max_connections: 50
    pool_recycle: 3600

# ==============================================================================
# HYPERLIQUID EXCHANGE
# ==============================================================================
hyperliquid:
  # Master address for all operations (from .env: HL_MASTER_ADDRESS)
  # Used for read-only queries, WebSocket, and as reference for subaccount operations
  user_address: "${HL_MASTER_ADDRESS}"

  # MASTER dry_run flag - controls ALL trading behavior
  # true = no real orders (safe testing)
  # false = real orders (live trading)
  dry_run: true

  # Testnet mode (if true, uses testnet API)
  testnet: false

  # --------------------------------------------------------------------------
  # SUBACCOUNTS
  # --------------------------------------------------------------------------
  # Subaccounts are managed via scripts/setup_hyperliquid.py
  # Master wallet credentials are in .env: HL_MASTER_ADDRESS, HL_MASTER_PRIVATE_KEY
  subaccounts:
    count: 8                       # Target number of subaccounts (max 10 per HL)
    naming_pattern: "Bot-{:03d}"   # Pattern for names: Bot-001, Bot-002, etc.

  # --------------------------------------------------------------------------
  # AGENT WALLETS
  # --------------------------------------------------------------------------
  # Agent wallets are API keys for trading (no withdrawal permissions)
  # Created automatically by scripts/setup_hyperliquid.py
  # Credentials stored in database (Credential table)
  agent_wallet:
    validity_days: 180             # Max validity (Hyperliquid limit)
    renewal_days_before_expiry: 30 # Renew 30 days before expiration

  # --------------------------------------------------------------------------
  # FUND MANAGEMENT
  # --------------------------------------------------------------------------
  # Automatic topup from master to subaccounts when balance falls below threshold
  # Policy: topup only from master, NEVER between subaccounts
  funds:
    min_operational_usd: 150       # Below this → trigger topup
    topup_target_usd: 200          # Target balance after topup
    master_reserve_usd: 100        # Never drain master below this
    min_tradeable_usd: 15          # Below this → subaccount cannot trade
    check_interval_hours: 24       # How often to check balances

  # --------------------------------------------------------------------------
  # FEES AND EXECUTION
  # --------------------------------------------------------------------------
  # Fees for backtesting (taker fee = market orders)
  fee_rate: 0.00045  # 0.045% taker fee
  slippage: 0.0005   # 0.05% estimated slippage
  min_notional: 10.0  # Minimum trade size in USDC (Hyperliquid requirement)

  websocket:
    ping_interval: 30
    ping_timeout: 10

  # Trade sync configuration
  # Synchronizes closed trades from Hyperliquid to database
  trade_sync:
    enabled: true
    fills_lookback_days: 7  # How far back to look for fills

# ==============================================================================
# FUNDING RATES (Hyperliquid Perpetuals)
# ==============================================================================
# Funding rates are applied hourly on Hyperliquid.
# This data is used in backtesting for more realistic PnL calculations.
funding:
  enabled: true                    # Enable funding rate modeling in backtest
  backfill_days: 180               # Days of historical funding to download
  # Fallback rate when data is missing (not used if data available)
  fallback_hourly_rate: 0.0001     # 0.01% per hour = ~0.24%/day

# ==============================================================================
# RISK MANAGEMENT
# ==============================================================================
risk:
  # Fixed Fractional position sizing (only mode supported)
  fixed_fractional:
    risk_per_trade_pct: 0.02       # 2% risk per trade
    max_position_size_pct: 0.20   # Max 20% of equity per position

  limits:
    max_open_positions_per_subaccount: 10  # Increased from 6

  emergency:
    # Thresholds
    max_portfolio_drawdown: 0.20      # 20% portfolio DD → force_close
    max_daily_loss: 0.10              # 10% daily loss → halt_entries
    max_subaccount_drawdown: 0.25     # 25% subaccount DD → halt_entries
    max_consecutive_losses: 10        # 10 consecutive losses → halt_entries
    data_stale_seconds: 120           # 2 min stale data → halt_entries

    # Recovery conditions
    rotation_loss_threshold: 0.00     # Rotate strategies with loss >= 0% (all losing)

  emergency_cooldowns:
    portfolio_dd_hours: 48            # 48h cooldown for portfolio DD (+ rotation)
    strategy_hours: 24                # 24h cooldown for consecutive losses
    # daily_loss: auto-reset at midnight UTC (no cooldown config needed)
    # subaccount_dd: reset on rotation (no cooldown config needed)
    # data_stale: reset when data valid (no cooldown config needed)

  # Trailing stop configuration
  trailing:
    enabled: true                    # Enable trailing stop service
    min_adjustment_pct: 0.005        # Min 0.5% improvement to update SL
    update_cooldown_sec: 10          # Min seconds between SL updates
    breakeven_buffer_pct: 0.002      # 0.2% buffer above breakeven

# ==============================================================================
# AI CONFIGURATION
# ==============================================================================
ai:
  mode: cli  # "cli" or "api"
  cli:
    model: claude
    timeout: 300
  api:
    model: claude-sonnet-4-20250514
    timeout: 120
  # Daily AI call limit (prevents runaway costs)
  daily_limit:
    enabled: true
    max_calls: 500       # Max AI calls per day
    reset_hour: 0        # Reset at midnight (local time)

# ==============================================================================
# GENERATION (AI Templates + Parametric Variations)
# ==============================================================================
generation:
  min_interval_seconds: 0      # Min seconds between AI calls
  parallel_threads: 1
  # NOTE: Each template generates ALL parametric variations (no AI cost)
  # Flow control is handled by pipeline backpressure below
  # Leverage is read from DB (coins.max_leverage), not configured here

  # Parametric optimization (runs in Backtester, not Generator)
  # Parameter space defined in src/backtester/parametric_constants.py (per-timeframe)
  parametric:
    enabled: true              # Enable parametric optimization in Backtester

  # Strategy sources - enable/disable each type
  # Names match generation_mode values for consistency
  #
  # COIN/DIRECTION SELECTION:
  # Each source can use market_regime for coin/direction selection:
  # - market_regime.enabled: false (DEFAULT) = top N coins by volume + round-robin direction
  # - market_regime.enabled: true = query market_regimes table for direction-aware selection
  #
  # SUPPORTED DIRECTIONS:
  # Each source declares which directions it can generate (round-robin cycles through these)
  # - [LONG, SHORT] = only unidirectional strategies
  # - [LONG, SHORT, BIDI] = also bidirectional (entry signal + EMA determines direction)
  strategy_sources:
    pattern:
      enabled: false           # PatStrat_* from pattern-discovery API
      supported_directions: [LONG, SHORT]  # Pattern-discovery API only provides long/short
      # NOTE: Pattern uses pattern.get_high_edge_coins(), no market_regime support

    pattern_gen:
      enabled: true            # PGnStrat_*/PGgStrat_* - Internal pattern generator
      market_regime:
        enabled: false         # DEFAULT: top N volume + round-robin direction
      supported_directions: [LONG, SHORT, BIDI]  # Full support including BIDI
      parametric_ratio: 0.50   # 50% single-block parametric variations
      template_ratio: 0.30     # 30% 2-3 block combinations (AND logic)
      innovative_ratio: 0.20   # 20% sequential/multi-lookback/volatility patterns

      # Genetic evolution settings (Phase 2)
      genetic:
        enabled: true            # Enable genetic evolution
        min_pool_score: 40       # Min score to enter genetic pool
        min_pool_size: 50        # Min ACTIVE strategies before genetic starts
        smart_ratio: 0.70        # 70% smart when both available
        genetic_ratio: 0.30      # 30% genetic when both available
        tournament_size: 3       # Tournament selection size
        mutation_rate: 0.20      # 20% mutation probability
        crossover_rate: 0.80     # 80% crossover probability

    ai_free:
      enabled: false           # AIFStrat_* - AI chooses indicators freely
      market_regime:
        enabled: false         # DEFAULT: top N volume + round-robin direction
      supported_directions: [LONG, SHORT]  # AI template uses different 'both' logic

    ai_assigned:
      enabled: false           # AIAStrat_* - AI uses IndicatorCombinator-assigned indicators
      market_regime:
        enabled: false         # DEFAULT: top N volume + round-robin direction
      supported_directions: [LONG, SHORT]  # AI template uses different 'both' logic

    unger:
      enabled: true            # UngStrat_* - Regime-coherent strategies (Unger method)
      market_regime:
        enabled: false         # DEFAULT: top N volume + round-robin direction
      supported_directions: [LONG, SHORT, BIDI]  # Full support including BIDI
      min_regime_strength: 0.5 # Minimum regime strength (used when market_regime.enabled=true)

      # Genetic evolution settings (UggStrat_*)
      genetic:
        enabled: true            # Enable genetic evolution for unger
        min_pool_score: 40       # Min score to enter genetic pool
        min_pool_size: 50        # Min ACTIVE unger strategies before genetic starts
        smart_ratio: 0.70        # 70% smart when both available
        genetic_ratio: 0.30      # 30% genetic when both available
        tournament_size: 3       # Tournament selection size
        mutation_rate: 0.20      # 20% mutation probability
        crossover_rate: 0.80     # 80% crossover probability

    pandas_ta:
      enabled: true            # PtaStrat_* - Pandas-TA indicator combinations
      market_regime:
        enabled: false         # DEFAULT: top N volume + round-robin direction
      supported_directions: [LONG, SHORT, BIDI]  # Full support including BIDI
      min_regime_strength: 0.5 # Minimum regime strength (used when market_regime.enabled=true)
      indicator_ratios:        # Distribution of indicator counts per strategy
        single: 0.30           # 30% strategies with 1 indicator
        double: 0.50           # 50% strategies with 2 indicators
        triple: 0.20           # 20% strategies with 3 indicators

  # When both AI sources are enabled, this ratio controls the mix
  # ai_free_ratio: 0.7 means 70% ai_free, 30% ai_assigned
  ai_free_ratio: 0.7

  # Indicator combinator settings (for ai_assigned strategies)
  indicator_combinator:
    max_main_indicators: 3     # 2 or 3 main indicators
    max_filter_indicators: 2   # 0, 1, or 2 filters
    prefer_2_indicators: true  # Try 2-indicator combos before 3-indicator

# ==============================================================================
# ACTIVE POOL (Leaderboard Logic)
# ==============================================================================
# Pool of strategies ready for deployment, managed via leaderboard
# New strategies enter if: score >= min_score AND (pool not full OR score > min(pool))
# NOTE: All strategies in ACTIVE are eligible for LIVE deployment (single threshold)
active_pool:
  max_size: 100                  # Max strategies in pool (10x buffer with 10 subaccounts)
  min_score: 40                  # Minimum score to enter pool (and be LIVE eligible)

# ==============================================================================
# PIPELINE FLOW CONTROL (Multi-Level Backpressure System)
# ==============================================================================
# Prevents queue overflow by limiting strategies at each stage.
# Each module checks its downstream queue before processing.
# System self-regulates: slow backtester -> queues fill -> upstream pauses
pipeline:
  queue_limits:
    generated: 100      # Max GENERATED strategies waiting for validation
    validated: 100      # Max VALIDATED strategies waiting for backtesting
    # ACTIVE pool uses active_pool.max_size (leaderboard logic)

  # Hysteresis backpressure for VALIDATED queue (prevents filling too fast)
  # Generator pauses when queue > high, resumes when queue < low
  # Keeps queue in optimal range for backtester throughput
  validated_backpressure:
    low_threshold: 20         # Resume generating when queue drops below this
    high_threshold: 50        # Pause generating when queue exceeds this

  backpressure:
    check_interval: 10        # Seconds between backpressure checks
    base_cooldown: 30         # Base cooldown when backpressure triggers
    max_cooldown: 120         # Maximum cooldown (2 minutes)
    cooldown_increment: 2     # Extra seconds per strategy over limit

  monitoring:
    log_interval: 30          # Log pipeline status every N seconds

# ==============================================================================
# PATTERN DISCOVERY (External API)
# ==============================================================================
pattern_discovery:
  api_url: http://localhost:8001

  # --------------------------------------------------------------------------
  # TIER CONFIGURATION
  # --------------------------------------------------------------------------
  # Tier 1: edge>=5%, N>=500/window, stability<1%, coins>=20 (PRODUCTION)
  # Tier 2: edge>=3%, N>=200/window, stability<2%, coins>=10 (BETA)
  # Tier 3: edge>=2%, N>=100/window, stability<3%, coins>=5 (ALPHA)
  #
  # All tiers are walk-forward validated by pattern-discovery.
  # Lower tiers have less strict requirements but still positive edge.
  tiers:
    enabled: [1, 2]            # Which tiers to use: [1], [1,2], [1,2,3]
    weights:                   # Relative weight when mixing tiers (for selection)
      1: 1.0                   # Tier 1: full weight (highest confidence)
      2: 0.7                   # Tier 2: 70% weight (good confidence)
      3: 0.4                   # Tier 3: 40% weight (moderate confidence)
    min_edge_override:         # Override minimum edge per tier (optional)
      2: 0.04                  # Tier 2: require at least 4% edge (stricter than default 3%)
      3: 0.03                  # Tier 3: require at least 3% edge (stricter than default 2%)

  # --------------------------------------------------------------------------
  # COIN SELECTION
  # --------------------------------------------------------------------------
  # Uses ALL coins meeting edge/signals criteria + liquidity filter from trading.min_volume_24h
  coin_selection:
    min_edge: 0.10             # 10% minimum edge to include coin
    min_signals: 50            # Minimum signals for statistical reliability

  # --------------------------------------------------------------------------
  # MULTI-TARGET EXPANSION
  # --------------------------------------------------------------------------
  # One pattern with N validated targets -> N strategies
  multi_target:
    enabled: true              # Enable multi-target expansion
    min_edge_for_expansion: 0.05  # 5% min edge per target to expand
    max_targets_per_pattern: 5    # Limit expansion per pattern

  # --------------------------------------------------------------------------
  # HELPERS (timeframe scaling functions)
  # --------------------------------------------------------------------------
  helpers:
    cache_ttl_seconds: 3600    # Cache helper functions for 1 hour

# ==============================================================================
# VALIDATION (Strategy Code Validation)
# ==============================================================================
validation:
  parallel_threads: 6

# ==============================================================================
# BACKTESTING
# ==============================================================================
backtesting:
  initial_capital: 10000
  batch_size: 500        # Strategies per batch for same base_code_hash

  # Thread allocation (3+1 elastic model for LIVE mode)
  threads:
    validated: 3             # Dedicated threads for new VALIDATED strategies
    retest: 1                # Elastic thread: re-backtest first, then VALIDATED if empty

  # Re-backtest configuration for ACTIVE pool freshness
  retest:
    interval_days: 1         # Re-test ACTIVE strategies daily (pool=50 is manageable)
    # Re-backtest uses: optimal TF only, 365+30 days, same parameters (no parametric)

  # In-sample/Out-of-sample split (unified approach)
  # Total period = is_days + oos_days = 180 days
  is_days: 120               # 4 months in-sample (rotation-based system, recent regimes)
  oos_days: 60               # Last 60 days out-of-sample (anti-overfitting + recency)
  min_coverage_pct: 0.80     # 80% minimum data coverage required for coins

  # Minimum trades per timeframe (parallel arrays with timeframes config)
  # Based on logical trading frequency per TF:
  # 15m: ~1.0 trades/day, 30m: ~0.67/day, 1h: ~0.42/day, 2h: ~0.25/day
  # timeframes: ['15m', '30m', '1h', '2h']
  min_trades:
    in_sample:     [120, 80, 50, 30]   # For 120d IS period
    out_of_sample: [60,  40, 25, 15]   # For 60d OOS period

  # Statistical significance filter (Confidence Interval)
  # CI = 1.96 × √(WR × (1-WR) / N)
  # Strategies with CI > max_ci are rejected (too much uncertainty)
  # Ratio IS/OOS ≈ 1.5 accounts for OOS having half the data
  max_ci:
    in_sample: 0.10      # 10% max CI for IS (requires N ≥ ~96 trades at WR=50%)
    out_of_sample: 0.15  # 15% max CI for OOS (requires N ≥ ~43 trades at WR=50%)

  # Out-of-sample validation thresholds
  # Note: OOS uses same thresholds as IS (min_sharpe, min_win_rate, etc.)
  # Only degradation and recency_weight are OOS-specific
  out_of_sample:
    max_degradation: 0.50    # Max 50% degradation from IS to OOS
    recency_weight: 0.60     # Weight for OOS score in final ranking

  # Walk-Forward Validation with FIXED parameters
  # Runs AFTER shuffle test, BEFORE pool entry
  # Tests if the best combo (params already embedded) performs consistently
  # across 4 expanding time windows. Uses expectancy >= min_expectancy (0.002)
  # as profitability criterion (more direct than Sharpe).
  wfa_validation:
    enabled: true
    window_percentages: [0.25, 0.50, 0.75, 1.0]  # Expanding windows
    min_profitable_windows: 4                     # All 4 windows must be profitable

  # Robustness filter (final gate before pool entry)
  # Runs AFTER WFA validation, validates strategy is likely to perform in live
  # Formula: robustness = oos_ratio*0.50 + trade_significance*0.35 + simplicity*0.15
  robustness:
    min_threshold: 0.80           # Minimum robustness score (0-1)
    weights:
      oos_ratio: 0.50             # OOS/IS Sharpe ratio weight (generalization)
      trade_significance: 0.35    # Trade count weight (statistical reliability)
      simplicity: 0.15            # Indicator count weight (overfitting resistance)
    trade_significance_target: 150  # Trades for max score (IS + OOS combined)

  # Minimum thresholds (gate check - classifier does the real ranking)
  thresholds:
    min_sharpe: 0.3          # Minimum Sharpe ratio
    min_win_rate: 0.35       # 35% minimum win rate
    min_total_trades: 10     # Minimum trades for significance
    min_expectancy: 0.002    # 0.2% per trade minimum (covers fees + ensures profitability)
    max_drawdown: 0.50       # Max 50% drawdown (now correctly calculated)

  # NOTE: realistic_mode and max_concurrent_positions removed
  # Backtest uses risk.limits.max_open_positions_per_subaccount for position limits

# ==============================================================================
# TRADING (Live Execution Policy)
# ==============================================================================
trading:
  # NOTE: n_subaccounts REMOVED - use hyperliquid.subaccounts.total instead
  total_capital: 500           # Total capital across all subaccounts ($) - 5 x $100
  min_volume_24h: 1000000      # $1M min volume for live trading (liquidity filter)
  pairs_mode: strict           # strict, adaptive, intersection
  require_backtest: true       # Only trade pairs that were backtested
  top_coins_limit: 30          # Default number of top coins by volume for trading_coins

# ==============================================================================
# SCORER (Score Calculation)
# ==============================================================================
scorer:
  # Unified scoring weights (used for both backtest and live)
  # Score = weighted sum of 5 normalized components (0-100 each)
  # All weights must sum to 1.0
  weights:
    expectancy: 0.40  # Expectancy - most important metric (+5% from removed robustness)
    sharpe: 0.25      # Risk-adjusted return (+5% from removed robustness)
    win_rate: 0.10    # Win rate (trades won / total trades)
    drawdown: 0.15    # Penalizes high drawdown (lower DD = higher score)
    recency: 0.10     # Recent performance vs training (from holdout degradation)

# ==============================================================================
# ROTATOR (ACTIVE -> LIVE Deployment)
# ==============================================================================
rotator:
  check_interval_minutes: 15     # Check every 15 min for deployment opportunities
  max_live_strategies: 8         # Max strategies in LIVE (= subaccounts.count)
  min_pool_size: 30              # Sbarramento: serve pool >= 30 prima di andare live
  # NOTE: min_score for LIVE eligibility uses active_pool.min_score (single threshold)

  # Diversification rules
  selection:
    max_per_type: 3              # Max strategies per type (MOM, REV, etc.)
    max_per_timeframe: 3         # Max strategies per timeframe
    max_per_direction: 5         # Max strategies per direction (LONG, SHORT, BIDIR)

# ==============================================================================
# MONITOR (LIVE Performance & Retirement)
# ==============================================================================
monitor:
  check_interval_minutes: 15     # Check every 15 min for retirement candidates

  # Retirement criteria (any triggers retirement)
  retirement:
    min_score: 35                # Score < 35 = retire (closer to entry threshold)
    max_score_degradation: 0.40  # 40% worse than backtest = retire
    max_drawdown: 0.25           # 25% live drawdown = retire ($25 max loss on $100)
    min_trades: 10               # Min trades before evaluating
    max_consecutive_losses: 10   # 10+ consecutive losses = regime change signal
    max_trades_degradation: 0.50 # 50%+ fewer trades than backtest = problem

  # Live scoring (for calculating score_live)
  live_scoring:
    min_trades_for_frequency: 10 # Min trades to calculate trade frequency
    min_days_for_frequency: 7    # Min days active for reliable frequency

# ==============================================================================
# CLASSIFICATION (LEGACY - Uses scorer.weights now)
# ==============================================================================
classification:
  frequency_hours: 0.25  # Every 15 minutes

  # DEPRECATED: Use scorer.weights instead (unified formula)
  # Kept for backwards compatibility during transition
  score_weights:
    expectancy: 0.45
    sharpe: 0.25
    win_rate: 0.15
    drawdown: 0.15

  filter_thresholds:
    min_sharpe: 0.5
    min_win_rate: 0.40
    min_trades: 20

  live_ranking:
    enabled: true
    min_trades_live: 10
    min_trades_for_frequency: 10
    min_days_for_frequency: 7
    retire_score_threshold: 30
    max_degradation_pct: 0.50
    max_drawdown_live: 0.30

  selection:
    top_n: 10
    max_per_type: 3
    max_per_timeframe: 3

  diversification:
    max_same_type: 3
    max_same_timeframe: 5

  archival:
    enabled: true
    score_threshold: 15
    max_per_cycle: 50
    min_age_hours: 1

# ==============================================================================
# DEPLOYMENT (LEGACY - Will be replaced by ROTATOR)
# ==============================================================================
deployment:
  rotation_frequency_hours: 24
  shutdown:
    close_positions: false
    cancel_orders: true

# ==============================================================================
# SUBACCOUNT MANAGER
# ==============================================================================
subaccount_manager:
  # dry_run removed - uses hyperliquid.dry_run as single source of truth
  rotation_interval_hours: 24
  rebalance_enabled: true

# ==============================================================================
# EXECUTOR (Live Trading Loop)
# ==============================================================================
executor:
  check_interval_seconds: 15       # How often to check for signals

# ==============================================================================
# MONITORING
# ==============================================================================
monitoring:
  snapshot_interval_minutes: 15
  check_interval_seconds: 15

# ==============================================================================
# METRICS & ANALYTICS
# ==============================================================================
metrics:
  # Collection interval for pipeline snapshots
  collection_interval: 15         # 15 seconds (for testing)

  # Data retention policies
  retention:
    raw_days: 7                   # Keep 5-min snapshots for 7 days
    hourly_days: 30               # Keep hourly aggregates for 30 days
    daily_forever: true           # Keep daily aggregates forever

  # Alert thresholds
  alerts:
    enabled: true

    backpressure:
      threshold: 0.90             # 90% queue utilization
      duration_minutes: 60        # Sustained for 1 hour

    throughput_degradation:
      min_strategies_per_hour: 5
      duration_hours: 2

    quality_degradation:
      min_sharpe: 0.3
      duration_hours: 24

# ==============================================================================
# LOGGING
# ==============================================================================
logging:
  level: INFO
  file: logs/sixbtc.log
  max_bytes: 10485760
  backup_count: 5
  modules:
    orchestrator: INFO
    executor: INFO
    backtester: INFO
    generator: INFO
    data_provider: WARNING

# ==============================================================================
# SCHEDULER (Maintenance Tasks)
# ==============================================================================
# All daily tasks run at 01:00 UTC sequentially (~2-3 min total)
# Timeline: restart(60s) → renew(30s) → funds(30s) → tmp(5s) → events(10s) → stale(10s)
scheduler:
  tasks:
    # Daily maintenance tasks run between 01:00-01:45 UTC, spaced 5 minutes apart
    # This window is chosen because it's low-activity period for crypto markets

    daily_restart_services:
      enabled: true
      interval_hours: 24          # Once per day
      restart_hour: 1             # Run at 01:00 UTC
      restart_minute: 0

    # Agent wallet credential renewal (checks daily, renews if expiring within 30 days)
    renew_agent_wallets:
      enabled: true
      interval_hours: 24          # Check once per day
      run_hour: 1                 # Run at 01:10 UTC
      run_minute: 10

    # Subaccount fund management (topup from master if balance low)
    check_subaccount_funds:
      enabled: true
      interval_hours: 24          # Check once per day
      run_hour: 1                 # Run at 01:15 UTC
      run_minute: 15

    # Clean /tmp directory (remove old temporary files)
    cleanup_tmp_dir:
      enabled: true
      interval_hours: 24          # Once per day
      run_hour: 1                 # Run at 01:20 UTC
      run_minute: 20
      max_age_hours: 24           # Delete files older than 24 hours

    # Clean old StrategyEvent records (audit trail, grows fast)
    cleanup_old_events:
      enabled: true
      interval_hours: 24          # Once per day
      run_hour: 1                 # Run at 01:25 UTC
      run_minute: 25
      max_age_days: 7             # Delete events older than 7 days

    # Clean stale strategies stuck in intermediate states (GENERATED/VALIDATED)
    cleanup_stale_strategies:
      enabled: true
      interval_hours: 24          # Once per day
      run_hour: 1                 # Run at 01:30 UTC
      run_minute: 30
      max_age_days: 1             # Delete if stuck > 1 day

    # Clean old FAILED strategies (validation failures)
    cleanup_old_failed:
      enabled: true
      interval_hours: 24          # Once per day
      run_hour: 1                 # Run at 01:35 UTC
      run_minute: 35
      max_age_days: 7             # Delete FAILED older than 7 days

    # Clean old RETIRED strategies (evicted from pool)
    cleanup_old_retired:
      enabled: true
      interval_hours: 24          # Once per day
      run_hour: 1                 # Run at 01:40 UTC
      run_minute: 40
      max_age_days: 7             # Delete RETIRED older than 7 days

    # Sync subaccount balances from Hyperliquid (reduces data staleness)
    sync_balances:
      enabled: true
      interval_minutes: 5         # Every 5 minutes for fresh balance data

# ==============================================================================
# DATA SCHEDULER
# ==============================================================================
# update_pairs runs first to refresh coin list, then download_data fetches OHLCV
data_scheduler:
  enabled: true
  top_pairs_count: 200
  min_volume_usd: 0
  download_days: null
  # update_pairs: refresh coin list from Hyperliquid x Binance
  update_pairs_hours: [1, 13]     # Run at 01:45 and 13:45 UTC
  update_pairs_minute: 45
  # download_data: fetch OHLCV data for all active coins (15 min after update_pairs)
  download_data_hours: [2, 14]    # Run at 02:00 and 14:00 UTC
  download_data_minute: 0

