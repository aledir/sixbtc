"""
PtaStrat: {{ entry_names }}
Timeframe: {{ timeframe }}
Direction: {{ direction }}
Regime: {{ regime_type }}
Exit Mechanism: {{ exit_mechanism.name }}
Generated: {{ generated_at }}
"""

from src.strategies.base import StrategyCore, Signal, StopLossType, TakeProfitType, ExitType
import pandas as pd
import pandas_ta as ta
import numpy as np


class {{ class_name }}(StrategyCore):
    """
    Entry: {{ entry_count }} indicator(s)
    {% for ec in entry_conditions %}
    - {{ ec.indicator.name }} {{ ec.condition_type.value }} {{ ec.threshold }}
    {% endfor %}
    Exit: {{ exit_mechanism.description }}
    SL: {{ sl_config.name }}
    {% if tp_config %}TP: {{ tp_config.name }}{% endif %}
    {% if trailing %}Trailing: {{ trailing.name }}{% endif %}
    """

    # Direction
    direction = '{{ direction | lower }}'

    # Timeframe (for Sharpe annualization)
    timeframe = '{{ timeframe }}'

    # Signal column for vectorized backtest
    signal_column = 'entry_signal'

    # Indicator columns for lookahead test
    {% if is_bidi %}
    indicator_columns = [{% for ec in entry_conditions_long %}'{{ ec.indicator.id | lower }}_long', {% endfor %}{% for ec in entry_conditions_short %}'{{ ec.indicator.id | lower }}_short', {% endfor %}{% if needs_atr %}'atr', {% endif %}'long_signal', 'short_signal', 'entry_signal']
    {% else %}
    indicator_columns = [{% for ec in entry_conditions %}'{{ ec.indicator.id | lower }}', {% endfor %}{% if needs_atr %}'atr', {% endif %}'entry_signal']
    {% endif %}

    # Parametric placeholders (expanded by backtester)
    SL_PCT = {{ sl_params.get('sl_pct', 0.02) }}
    TP_PCT = {{ tp_params.get('tp_pct', 0.04) if tp_params else 0.04 }}
    LEVERAGE = 1
    LOOKBACK = {{ max_lookback }}
    {% if exit_params and exit_params.get('N') %}
    exit_after_bars = {{ exit_params.get('N', 20) }}
    {% else %}
    exit_after_bars = 0  # No time-based exit
    {% endif %}

    # Stop Loss config
    {% if sl_config.sl_type == 'atr' %}
    sl_type = StopLossType.ATR
    atr_stop_multiplier = {{ sl_params.get('atr_multiplier', 2.0) }}
    {% elif sl_config.sl_type == 'structure' %}
    sl_type = StopLossType.STRUCTURE
    structure_lookback = {{ sl_params.get('lookback', 10) }}
    {% elif sl_config.sl_type == 'trailing' %}
    sl_type = StopLossType.TRAILING
    trailing_stop_pct = {{ sl_params.get('trailing_pct', 0.02) }}
    trailing_activation_pct = {{ sl_params.get('activation_pct', 0.01) }}
    {% else %}
    sl_type = StopLossType.PERCENTAGE
    {% endif %}

    # Take Profit config
    {% if tp_config %}
    {% if tp_config.tp_type == 'atr' %}
    tp_type = TakeProfitType.ATR
    atr_take_multiplier = {{ tp_params.get('atr_multiplier', 3.0) }}
    {% elif tp_config.tp_type == 'rr_ratio' %}
    tp_type = TakeProfitType.RR_RATIO
    rr_ratio = {{ tp_params.get('rr_ratio', 2.0) }}
    {% else %}
    tp_type = TakeProfitType.PERCENTAGE
    {% endif %}
    {% else %}
    tp_type = TakeProfitType.PERCENTAGE
    {% endif %}

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Pre-calculate indicators and entry_signal for vectorized backtesting.

        Uses pandas_ta library for indicator calculations.
        The backtester reads entry_signal directly (no per-bar loop).
        """
        df = df.copy()

        # === CALCULATE INDICATORS ===
        {% if is_bidi %}
        # BIDI: Calculate indicators for LONG conditions
        {% for ec in entry_conditions_long %}
        # LONG Indicator {{ loop.index }}: {{ ec.indicator.name }}
        {% if ec.indicator.input_type == 'hlc' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hl' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlcv' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hlcv' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'cv' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlc' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'oc' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'volume' %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% else %}
        {{ ec.indicator.id | lower }}_long_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% endif %}
        if isinstance({{ ec.indicator.id | lower }}_long_result, pd.DataFrame):
            df['{{ ec.indicator.id | lower }}_long'] = {{ ec.indicator.id | lower }}_long_result.iloc[:, 0]
        else:
            df['{{ ec.indicator.id | lower }}_long'] = {{ ec.indicator.id | lower }}_long_result

        {% endfor %}
        # BIDI: Calculate indicators for SHORT conditions
        {% for ec in entry_conditions_short %}
        # SHORT Indicator {{ loop.index }}: {{ ec.indicator.name }}
        {% if ec.indicator.input_type == 'hlc' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hl' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlcv' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hlcv' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'cv' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlc' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'oc' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'volume' %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% else %}
        {{ ec.indicator.id | lower }}_short_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% endif %}
        if isinstance({{ ec.indicator.id | lower }}_short_result, pd.DataFrame):
            df['{{ ec.indicator.id | lower }}_short'] = {{ ec.indicator.id | lower }}_short_result.iloc[:, 0]
        else:
            df['{{ ec.indicator.id | lower }}_short'] = {{ ec.indicator.id | lower }}_short_result

        {% endfor %}
        {% else %}
        # NON-BIDI: Calculate indicators from entry_conditions
        {% for ec in entry_conditions %}
        # Indicator {{ loop.index }}: {{ ec.indicator.name }}
        {% if ec.indicator.input_type == 'hlc' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hl' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlcv' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'hlcv' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['high'], df['low'], df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'cv' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'], df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'ohlc' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['high'], df['low'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'oc' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['open'], df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% elif ec.indicator.input_type == 'volume' %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['volume'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% else %}
        {{ ec.indicator.id | lower }}_result = ta.{{ ec.indicator.pandas_ta_func }}(
            df['close'],
            {% for param, value in ec.indicator_params.items() %}
            {{ param }}={% if value is string %}"{{ value }}"{% else %}{{ value }}{% endif %},
            {% endfor %}
        )
        {% endif %}
        # Handle both Series and DataFrame results (some indicators return DataFrame even with single output)
        if isinstance({{ ec.indicator.id | lower }}_result, pd.DataFrame):
            df['{{ ec.indicator.id | lower }}'] = {{ ec.indicator.id | lower }}_result.iloc[:, 0]
        else:
            df['{{ ec.indicator.id | lower }}'] = {{ ec.indicator.id | lower }}_result

        {% endfor %}
        {% endif %}

        {% if needs_atr %}
        # ATR for SL/TP calculations
        df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=14)
        {% endif %}

        # === VECTORIZED ENTRY SIGNAL ===
        {% if is_bidi %}
        # === BIDI: Separate LONG and SHORT entry conditions ===
        # LONG uses entry_conditions_long, SHORT uses entry_conditions_short

        # --- LONG SIGNAL ---
        long_signal = pd.Series(True, index=df.index)
        {% for ec in entry_conditions_long %}
        # LONG Condition {{ loop.index }}: {{ ec.indicator.name }} {{ ec.condition_type.value }} {{ ec.threshold }}
        {% if ec.condition_type.value == 'threshold_below' %}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_long'] < {{ ec.threshold }}
        {% elif ec.condition_type.value == 'threshold_above' %}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_long'] > {{ ec.threshold }}
        {% elif ec.condition_type.value == 'crossed_above' %}
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_long'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_long'].shift(1) <= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'crossed_below' %}
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_long'] < {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_long'].shift(1) >= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'between' %}
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_long'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_long'] < {{ ec.threshold_high }})
        {% elif ec.condition_type.value == 'slope_up' %}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_long'] > df['{{ ec.indicator.id | lower }}_long'].shift(1)
        {% elif ec.condition_type.value == 'slope_down' %}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_long'] < df['{{ ec.indicator.id | lower }}_long'].shift(1)
        {% endif %}
        long_signal = long_signal & long_cond_{{ loop.index }}
        {% endfor %}

        # --- SHORT SIGNAL ---
        short_signal = pd.Series(True, index=df.index)
        {% for ec in entry_conditions_short %}
        # SHORT Condition {{ loop.index }}: {{ ec.indicator.name }} {{ ec.condition_type.value }} {{ ec.threshold }}
        {% if ec.condition_type.value == 'threshold_below' %}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_short'] < {{ ec.threshold }}
        {% elif ec.condition_type.value == 'threshold_above' %}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_short'] > {{ ec.threshold }}
        {% elif ec.condition_type.value == 'crossed_above' %}
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_short'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_short'].shift(1) <= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'crossed_below' %}
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_short'] < {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_short'].shift(1) >= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'between' %}
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}_short'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}_short'] < {{ ec.threshold_high }})
        {% elif ec.condition_type.value == 'slope_up' %}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_short'] > df['{{ ec.indicator.id | lower }}_short'].shift(1)
        {% elif ec.condition_type.value == 'slope_down' %}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}_short'] < df['{{ ec.indicator.id | lower }}_short'].shift(1)
        {% endif %}
        short_signal = short_signal & short_cond_{{ loop.index }}
        {% endfor %}

        # Store BIDI signals
        df['long_signal'] = long_signal.astype(bool)
        df['short_signal'] = short_signal.astype(bool)
        df['entry_signal'] = (long_signal | short_signal).astype(bool)
        {% elif direction | lower == 'bidi' %}
        # Legacy BIDI: Generate separate long/short signals with opposite thresholds
        long_signal = pd.Series(True, index=df.index)
        short_signal = pd.Series(True, index=df.index)

        {% for ec in entry_conditions %}
        # Condition {{ loop.index }}: {{ ec.indicator.name }}
        {% if ec.condition_type.value == 'threshold_below' %}
        # Long: {{ ec.indicator.id }} < {{ ec.threshold }} | Short: {{ ec.indicator.id }} > {{ ec.threshold_opposite or 70 }}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold }}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold_opposite or 70 }}
        {% elif ec.condition_type.value == 'threshold_above' %}
        # Long: {{ ec.indicator.id }} > {{ ec.threshold }} | Short: {{ ec.indicator.id }} < {{ ec.threshold_opposite or 30 }}
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold_opposite or 30 }}
        {% elif ec.condition_type.value == 'crossed_above' %}
        # Long: crossed above | Short: crossed below
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) <= {{ ec.threshold }})
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold_opposite or ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) >= {{ ec.threshold_opposite or ec.threshold }})
        {% elif ec.condition_type.value == 'crossed_below' %}
        # Long: crossed below | Short: crossed above
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) >= {{ ec.threshold }})
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold_opposite or ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) <= {{ ec.threshold_opposite or ec.threshold }})
        {% elif ec.condition_type.value == 'between' %}
        # Long: between low and high | Short: outside range (inverted)
        long_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold_high }})
        short_cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold }}) | (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold_high }})
        {% elif ec.condition_type.value == 'slope_up' %}
        # Long: slope up | Short: slope down
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > df['{{ ec.indicator.id | lower }}'].shift(1)
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < df['{{ ec.indicator.id | lower }}'].shift(1)
        {% elif ec.condition_type.value == 'slope_down' %}
        # Long: slope down | Short: slope up
        long_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < df['{{ ec.indicator.id | lower }}'].shift(1)
        short_cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > df['{{ ec.indicator.id | lower }}'].shift(1)
        {% endif %}
        long_signal = long_signal & long_cond_{{ loop.index }}
        short_signal = short_signal & short_cond_{{ loop.index }}

        {% endfor %}
        # Store BIDI signals
        df['long_signal'] = long_signal.astype(bool)
        df['short_signal'] = short_signal.astype(bool)
        df['entry_signal'] = (long_signal | short_signal).astype(bool)
        {% else %}
        # Unidirectional: single entry signal
        entry_signal = pd.Series(True, index=df.index)

        {% for ec in entry_conditions %}
        # Condition {{ loop.index }}: {{ ec.indicator.name }} {{ ec.condition_type.value }} {{ ec.threshold }}
        {% if ec.condition_type.value == 'threshold_below' %}
        cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold }}
        {% elif ec.condition_type.value == 'threshold_above' %}
        cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}
        {% elif ec.condition_type.value == 'crossed_above' %}
        cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) <= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'crossed_below' %}
        cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'].shift(1) >= {{ ec.threshold }})
        {% elif ec.condition_type.value == 'between' %}
        cond_{{ loop.index }} = (df['{{ ec.indicator.id | lower }}'] > {{ ec.threshold }}) & (df['{{ ec.indicator.id | lower }}'] < {{ ec.threshold_high }})
        {% elif ec.condition_type.value == 'slope_up' %}
        cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] > df['{{ ec.indicator.id | lower }}'].shift(1)
        {% elif ec.condition_type.value == 'slope_down' %}
        cond_{{ loop.index }} = df['{{ ec.indicator.id | lower }}'] < df['{{ ec.indicator.id | lower }}'].shift(1)
        {% endif %}
        entry_signal = entry_signal & cond_{{ loop.index }}

        {% endfor %}
        # Store as boolean column
        df['entry_signal'] = entry_signal.astype(bool)
        {% endif %}

        return df

    def generate_signal(self, df: pd.DataFrame, symbol: str = None) -> Signal | None:
        """
        Generate signal for LIVE execution (reads pre-calculated entry_signal).

        For backtest, the entry_signal column is read directly by the engine.
        """
        if len(df) < self.LOOKBACK + 10:
            return None

        # Read pre-calculated entry signal
        if not df['entry_signal'].iloc[-1]:
            return None

        # === BUILD SIGNAL ===
        {% if direction | lower == 'bidi' %}
        # BIDI: Determine direction from which signal fired
        if df['long_signal'].iloc[-1]:
            signal_direction = 'long'
        elif df['short_signal'].iloc[-1]:
            signal_direction = 'short'
        else:
            return None  # Should not happen if entry_signal is True
        {% else %}
        signal_direction = '{{ direction | lower }}'
        {% endif %}

        signal_kwargs = {
            'direction': signal_direction,
            'leverage': self.LEVERAGE,

            # Stop Loss (type-aware, optimized by typed parametric backtest)
            'sl_type': self.sl_type,
            'sl_pct': self.SL_PCT,
            {% if sl_config.sl_type == 'atr' %}
            'atr_stop_multiplier': self.atr_stop_multiplier,
            {% elif sl_config.sl_type == 'structure' %}
            # Calculate sl_price from lookback (swing low for long, swing high for short)
            {% if direction == 'SHORT' %}
            'sl_price': df['high'].iloc[-self.structure_lookback:].max(),
            {% else %}
            'sl_price': df['low'].iloc[-self.structure_lookback:].min(),
            {% endif %}
            {% elif sl_config.sl_type == 'trailing' %}
            'trailing_stop_pct': self.trailing_stop_pct,
            'trailing_activation_pct': self.trailing_activation_pct,
            {% endif %}

            # Take Profit (type-aware, optimized by typed parametric backtest)
            'tp_type': self.tp_type,
            'tp_pct': self.TP_PCT,
            {% if tp_config and tp_config.tp_type == 'atr' %}
            'atr_take_multiplier': self.atr_take_multiplier,
            {% elif tp_config and tp_config.tp_type == 'rr_ratio' %}
            'rr_ratio': self.rr_ratio,
            {% endif %}

            # Time-based Exit (read from class attribute, may be 0 for no time exit)
            'exit_after_bars': self.exit_after_bars,

            'reason': '{{ entry_reason }}',
        }

        return Signal(**signal_kwargs)

    {% if exit_condition and exit_condition.category != 'time' and exit_logic %}
    def should_exit(self, df: pd.DataFrame, position_bars: int) -> bool:
        """
        Check dynamic exit conditions.
        Exit Mechanism: {{ exit_mechanism.name }} ({{ exit_mechanism.logic }})
        Exit Condition: {{ exit_condition.name }}
        """
        # Exit Condition: {{ exit_condition.name }}
        {{ exit_logic | indent(8) }}

        {% if exit_mechanism.logic == 'AND' %}
        # AND logic: exit only if both conditions met
        return exit_signal
        {% else %}
        # OR logic: exit if exit_signal
        return exit_signal
        {% endif %}
    {% endif %}
