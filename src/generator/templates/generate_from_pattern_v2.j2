You are an expert quantitative trader. Create a StrategyCore class that uses the provided pattern function.

=== PATTERN INFORMATION ===

Name: {{ pattern.name }}
Direction: {{ pattern.target_direction | upper }} ONLY
Timeframe: {{ pattern.timeframe }}
Target: {{ pattern.target_name }}
Holding Period: {{ pattern.holding_period or "4h" }}

Performance:
  - Edge: {{ "%.2f"|format(pattern.test_edge * 100) }}%
  - Win Rate: {{ "%.1f"|format(pattern.test_win_rate * 100) }}%
  - Quality Score: {{ "%.2f"|format(pattern.quality_score) }}

{% if pattern.formula_readable %}
Pattern Logic: {{ pattern.formula_readable }}
{% endif %}

=== EXECUTABLE SOURCE CODE (USE THIS EXACTLY) ===

The pattern-discovery API provides the EXACT Python code. DO NOT modify the logic.

```python
{{ pattern.formula_source }}
```

{% if pattern.formula_components %}
Return Expression: {{ pattern.formula_components.get('return_expression', 'N/A') }}
Category: {{ pattern.formula_components.get('category', 'N/A') }}
{% endif %}

=== TIMEFRAME BAR MAPPINGS (for {{ pattern.timeframe }}) ===

Use these EXACT values for bars_*() functions:

```python
{% for period, bars in timeframe_bars.items() %}
def bars_{{ period }}(): return {{ bars }}
{% endfor %}
```

{% if helpers %}
=== HELPER FUNCTIONS (from API) ===

These helper functions may be required by the pattern:

{% for name, code in helpers.items() %}
```python
{{ code }}
```

{% endfor %}
{% endif %}

=== EXIT STRATEGY (CRITICAL) ===

Pattern-discovery validated this pattern with TIME-BASED exit after {{ pattern.holding_period or "24h" }}.
The strategy MUST use ExitType.TIME_BASED with the correct holding period.

A protective stop loss is added to prevent catastrophic losses, but it should be WIDE enough
to not interfere with normal market movements during the holding period.

Holding period in bars: {{ holding_bars or 96 }} bars (for {{ pattern.timeframe }} timeframe)

=== STRICT REQUIREMENTS ===

1. DIRECTION: Generate signals ONLY for {{ pattern.target_direction | upper }}
2. LEVERAGE: Use leverage = {{ leverage }}
3. PATTERN CODE: Use the EXACT formula_source code provided above
4. EXIT: Use TIME_BASED exit with {{ holding_bars or 96 }} bars (matching pattern-discovery validation)
5. STOP LOSS: Wide protective stop (3x ATR) to avoid premature exits
6. NO MODIFICATIONS: Do NOT change the pattern logic - it was validated with this exact code

=== OUTPUT FORMAT ===

Generate ONLY the Python code block. No explanations.

```python
import pandas as pd
import numpy as np
import talib as ta
from src.strategies.base import StrategyCore, Signal, StopLossType, TakeProfitType, ExitType

# =============================================================================
# TIMEFRAME BAR MAPPINGS (precomputed for {{ pattern.timeframe }})
# =============================================================================
{% for period, bars in timeframe_bars.items() %}
def bars_{{ period }}(): return {{ bars }}
{% endfor %}

{% if helpers %}
# =============================================================================
# HELPER FUNCTIONS
# =============================================================================
{% for name, code in helpers.items() %}
{{ code }}

{% endfor %}
{% endif %}

# =============================================================================
# PATTERN FUNCTION: {{ pattern.name }}
# {{ pattern.formula_readable or '' }}
# =============================================================================
{{ pattern.formula_source }}


class Strategy_{{ pattern.strategy_type or "GEN" }}_{{ strategy_id }}(StrategyCore):
    """
    Pattern-based strategy: {{ pattern.name }}
    Target: {{ pattern.target_name }}
    Direction: {{ pattern.target_direction | upper }} only
    Timeframe: {{ pattern.timeframe }}
    Holding Period: {{ pattern.holding_period or "24h" }} ({{ holding_bars or 96 }} bars)

    Pattern Edge: {{ "%.2f"|format(pattern.test_edge * 100) }}%
    Pattern Win Rate: {{ "%.1f"|format(pattern.test_win_rate * 100) }}%

    EXIT STRATEGY: Time-based exit after holding period.
    Pattern-discovery validated with hold-and-check-target approach.
    Wide protective stop (3x ATR) to avoid premature exits.

    Uses two-phase approach:
    1. calculate_indicators() - Pre-calculate ATR and pattern result
    2. generate_signal() - Read pre-calculated values
    """

    leverage = {{ leverage }}

    # Indicator columns added by calculate_indicators()
    indicator_columns = ['atr', 'pattern_signal']

    def __init__(self, params: dict = None):
        super().__init__(params)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Pre-calculate indicators: ATR and pattern signal.

        The pattern function is called here ONCE on the full dataframe.
        """
        df = df.copy()

        # ATR for protective stop
        df['atr'] = ta.ATR(df['high'], df['low'], df['close'], timeperiod=14)

        # Call pattern function ONCE on full dataframe
        try:
            pattern_result = {{ pattern.name.split('.')[-1] }}(df)
            if isinstance(pattern_result, pd.Series):
                df['pattern_signal'] = pattern_result
            else:
                # Scalar result - apply to last bar only
                df['pattern_signal'] = False
                df.loc[df.index[-1], 'pattern_signal'] = pattern_result
        except Exception:
            df['pattern_signal'] = False

        return df

    def generate_signal(self, df: pd.DataFrame, symbol: str = None) -> Signal | None:
        """
        Generate {{ pattern.target_direction }} signal from pre-calculated pattern.

        Uses TIME_BASED exit matching pattern-discovery validation.
        Protective stop at 3x ATR to prevent catastrophic losses.
        """
        min_bars = 100
        if len(df) < min_bars:
            return None

        # Read pre-calculated values
        current_atr = df['atr'].iloc[-1]
        entry_condition = bool(df['pattern_signal'].iloc[-1])

        if pd.isna(current_atr) or current_atr <= 0:
            return None

        if entry_condition:
            return Signal(
                direction='{{ pattern.target_direction }}',
                leverage=self.leverage,
                # Wide protective stop - 3x ATR to avoid premature exits
                sl_type=StopLossType.ATR,
                atr_stop_multiplier=3.0,
                # TIME-BASED exit matching pattern-discovery validation
                exit_type=ExitType.TIME_BASED,
                exit_after_bars={{ holding_bars or 96 }},
                reason="Pattern {{ pattern.name }} [{{ pattern.target_name }}]: {{ pattern.formula_readable or 'condition met' }}"
            )

        return None
```

Generate the complete code now. Keep the pattern function EXACTLY as provided.
