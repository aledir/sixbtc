You are an expert quantitative trader. Generate a PARAMETERIZED strategy template following the EXACT structure specified below.

=== STRATEGY SPECIFICATION ===

Strategy Type: {{ strategy_type }}
Timeframe: {{ timeframe }}
Template ID: {{ template_id }}

=== MANDATORY STRUCTURE ===

This template MUST follow this EXACT structure. Do NOT add or remove components.

{% if structure.entry_long and structure.entry_short %}
ENTRY: BIDIRECTIONAL (both long AND short entries required)
{% elif structure.entry_long %}
ENTRY: LONG ONLY (generate ONLY long entries, NO short entries)
{% else %}
ENTRY: SHORT ONLY (generate ONLY short entries, NO long entries)
{% endif %}

{% if structure.trailing_stop %}
STOP LOSS: TRAILING (sl_type=StopLossType.TRAILING)
- Uses trailing_stop_pct: distance from high water mark
- Uses trailing_activation_pct: profit threshold before trailing activates
{% else %}
STOP LOSS: ALWAYS REQUIRED (use ATR-based or percentage-based)
{% endif %}

{% if structure.take_profit %}
TAKE PROFIT: REQUIRED (use ATR, RR_RATIO, or percentage-based)
{% else %}
TAKE PROFIT: DO NOT USE (tp_type must NOT be set)
{% endif %}

{% if structure.exit_indicator %}
EXIT INDICATOR: REQUIRED
- Generate Signal(direction='close') when exit condition is met
- Exit condition should be based on indicator reversal (e.g., RSI returns to neutral)
- This is SEPARATE from stop loss/take profit
{% else %}
EXIT INDICATOR: DO NOT GENERATE (no direction='close' signals)
{% endif %}

{% if structure.time_exit %}
TIME EXIT: REQUIRED
- Include exit_type=ExitType.TIME_BASED in Signal
- Include exit_after_bars={{ "{{ exit_bars }}" }} parameter
{% else %}
TIME EXIT: DO NOT USE
{% endif %}

=== STRATEGY TYPE GUIDANCE ===

{% if strategy_type == 'MOM' %}
MOMENTUM Strategy:
- Identify trending moves early using momentum indicators
- RSI divergences, MACD crossovers, ROC, momentum oscillators
- Entry on breakouts or momentum confirmation
{% elif strategy_type == 'REV' %}
MEAN REVERSION Strategy:
- Identify overbought/oversold extreme conditions
- RSI extremes, Bollinger Band touches, deviation from mean
- Entry on bounces from statistical extremes
{% elif strategy_type == 'TRN' %}
TREND FOLLOWING Strategy:
- Ride established trends
- Moving average crossovers, ADX confirmation, trend strength
- Entry on pullbacks within strong trends
{% elif strategy_type == 'BRE' %}
BREAKOUT Strategy:
- Trade range/consolidation breakouts
- Support/resistance levels, Donchian channels, N-bar highs/lows
- Entry on volume-confirmed breakouts
{% elif strategy_type == 'VOL' %}
VOLATILITY Strategy:
- Trade volatility expansions and contractions
- Bollinger Band squeeze, ATR breakouts, Keltner channels
- Entry on volatility expansion from squeeze
{% elif strategy_type == 'SCA' %}
SCALPING Strategy:
- Quick entries and exits on minor price movements
- Short-term oscillators, micro-trends, fast EMAs
- Tight stops, quick profits
{% endif %}

=== ENTRY LOGIC CATEGORIES ===

Choose ONE primary category for your entry logic. This creates diversity across templates.
DO NOT rely only on TA-Lib indicators - explore other approaches!

**1. INDICATOR-BASED** (Traditional TA)
   Common oscillators: RSI, MACD, Stochastic, CCI, Williams %R, MFI
   Moving averages: EMA, SMA, WMA, DEMA, TEMA, KAMA
   Bands/Channels: BBANDS (Bollinger), Keltner, Donchian
   Trend: ADX, Supertrend, Parabolic SAR, Ichimoku
   Less common: AROON, CMO, TRIX, ULTOSC, ROC, Fisher

   Libraries available:
   - TA-Lib: `ta.RSI()`, `ta.BBANDS()`, `ta.MACD()`, etc.
   - pandas_ta: `df.ta.supertrend()`, `df.ta.squeeze()`, `df.ta.vwap()`, `df.ta.ichimoku()`

   Example TA-Lib: `rsi = ta.RSI(df['close'], {{ "{{ indicator_period }}" }})`
   Example pandas_ta: `supertrend = df.ta.supertrend(length={{ "{{ indicator_period }}" }})`

**2. PRICE ACTION** (No indicators, pure price)
   - Break of previous day/week high or low
   - Higher highs / lower lows sequence
   - Price vs previous N bars high/low
   - Example: `break_high = df['close'].iloc[-1] > df['high'].iloc[-2:-{{ "{{ lookback }}" }}].max()`

**3. CANDLESTICK PATTERNS** (Single or multi-bar)
   - Engulfing (bullish/bearish)
   - Pin bar / Hammer / Shooting star
   - Inside bar breakout
   - Doji at extremes
   - Example: `engulf = (df['close'].iloc[-1] > df['open'].iloc[-2]) and (df['open'].iloc[-1] < df['close'].iloc[-2])`

**4. BODY/RANGE ANALYSIS** (Candle anatomy)
   - Large body candles (momentum)
   - Small body = indecision
   - Body vs wick ratio
   - Range expansion/contraction
   - Example: `body = abs(df['close'].iloc[-1] - df['open'].iloc[-1]); range_ = df['high'].iloc[-1] - df['low'].iloc[-1]`

**5. STRUCTURE-BASED** (Market structure)
   - Support/resistance levels (swing highs/lows)
   - Double top/bottom
   - Trend line breaks
   - Pivot points (daily PP, R1, S1)
   - Example: `swing_low = df['low'].rolling({{ "{{ lookback }}" }}).min().iloc[-1]`

**6. VOLUME-BASED** (Volume as primary trigger)
   - Volume spike entry (volume > N x average)
   - Volume dry-up reversal
   - Price + volume confirmation
   - Example: `vol_avg = df['volume'].rolling(20).mean().iloc[-1]; vol_spike = df['volume'].iloc[-1] > vol_avg * {{ "{{ volume_mult }}" }}`

**7. STATISTICAL** (Quantitative approach)
   - Z-score of price (deviation from mean)
   - Percentile rank
   - Standard deviation bands
   - Linear regression channel
   - Example: `z = (df['close'].iloc[-1] - df['close'].rolling({{ "{{ period }}" }}).mean().iloc[-1]) / df['close'].rolling({{ "{{ period }}" }}).std().iloc[-1]`

**8. MULTI-TIMEFRAME PROXY** (Simulated HTF levels)
   - Use longer lookback to simulate higher timeframe
   - Daily levels on intraday (e.g., 96-bar high on 15m = daily high)
   - Example for 15m simulating daily: `daily_high = df['high'].rolling(96).max().iloc[-1]`

IMPORTANT: Be CREATIVE! Combine categories or use less common approaches.
The walk-forward validation will filter out strategies that don't work.

=== PARAMETERIZATION RULES ===

Your code MUST use Jinja2 placeholders for ALL variable parameters.
Use double braces: {{ "{{ parameter_name }}" }}

REQUIRED PARAMETERS (include ALL of these):
- {{ "{{ indicator_period }}" }} - Main indicator lookback period
- {{ "{{ entry_threshold }}" }} - Entry trigger threshold
{% if structure.exit_indicator %}
- {{ "{{ exit_threshold }}" }} - Exit indicator threshold
{% endif %}
{% if structure.trailing_stop %}
- {{ "{{ trailing_stop_pct }}" }} - Trail distance from high water mark (e.g., 0.02 = 2%)
- {{ "{{ trailing_activation_pct }}" }} - Profit threshold to activate trailing (e.g., 0.01 = 1%)
{% else %}
- {{ "{{ atr_multiplier }}" }} - ATR multiplier for stop loss (be creative with values!)
{% endif %}
{% if structure.time_exit %}
- {{ "{{ exit_bars }}" }} - Number of bars for time-based exit
{% endif %}

NOTE: Do NOT include "leverage" as a parameter - it will be assigned automatically by the system.

OPTIONAL ADDITIONAL PARAMETERS (choose 1-3 based on your entry logic category):

For INDICATOR-BASED:
- {{ "{{ fast_period }}" }}, {{ "{{ slow_period }}" }} - For crossover strategies
- {{ "{{ threshold_high }}" }}, {{ "{{ threshold_low }}" }} - For range-based entries

For PRICE ACTION / STRUCTURE:
- {{ "{{ lookback }}" }} - Bars to look back for highs/lows/structure
- {{ "{{ break_threshold }}" }} - Minimum break distance (e.g., 0.001 = 0.1%)

For CANDLESTICK / BODY-RANGE:
- {{ "{{ body_ratio }}" }} - Minimum body/range ratio (e.g., 0.6 = 60%)
- {{ "{{ wick_ratio }}" }} - Maximum wick ratio for pin bars

For VOLUME-BASED:
- {{ "{{ volume_mult }}" }} - Volume spike multiplier (e.g., 2.0 = 2x average)
- {{ "{{ volume_period }}" }} - Volume average period

For STATISTICAL:
- {{ "{{ z_threshold }}" }} - Z-score threshold (e.g., 2.0)
- {{ "{{ percentile }}" }} - Percentile threshold (e.g., 5, 95)

For MULTI-TIMEFRAME PROXY:
- {{ "{{ htf_lookback }}" }} - Higher timeframe lookback (e.g., 96 for daily on 15m)

=== NO LOOKAHEAD BIAS ===

FORBIDDEN patterns (will be rejected):
- rolling(center=True)
- shift(-N) where N > 0
- Any access to future data

ALLOWED patterns:
- rolling(N) without center
- shift(N) where N >= 0
- iloc[-1] for current bar
- iloc[-2] for previous bar

=== CODE TEMPLATE ===

IMPORTANT: The strategy uses a TWO-PHASE approach:
1. calculate_indicators(df) - Pre-calculate ALL indicators ONCE
2. generate_signal(df) - Read pre-calculated values and generate signal

This enables:
- O(n) instead of O(n^2) indicator calculation in backtests
- Freqtrade-style lookahead bias detection
- Potential Numba optimization

```python
import pandas as pd
import numpy as np
import talib as ta
import pandas_ta as pta  # Optional: for supertrend, squeeze, vwap, ichimoku, etc.
from src.strategies.base import StrategyCore, Signal, StopLossType, TakeProfitType{% if structure.time_exit %}, ExitType{% endif %}


class Strategy_{{ strategy_type }}_{{ template_id }}(StrategyCore):
    """
    {{ strategy_type }} strategy template for {{ timeframe }} timeframe
    Structure: {{ structure.name }}

    Parameters:
    - indicator_period: Main indicator lookback
    - entry_threshold: Entry trigger level
{% if structure.exit_indicator %}
    - exit_threshold: Exit trigger level
{% endif %}
{% if structure.trailing_stop %}
    - trailing_stop_pct: Trail distance from high water mark
    - trailing_activation_pct: Profit threshold to activate trailing
{% else %}
    - atr_multiplier: Stop loss ATR multiplier
{% endif %}
{% if structure.time_exit %}
    - exit_bars: Time-based exit after N bars
{% endif %}
    - leverage: Assigned automatically by system (not a template parameter)

{% if structure.entry_long and structure.entry_short %}
    Entry Long: [describe long entry condition]
    Entry Short: [describe short entry condition]
{% elif structure.entry_long %}
    Entry Long: [describe long entry condition]
    Entry Short: NOT GENERATED (structure is LONG_ONLY)
{% else %}
    Entry Long: NOT GENERATED (structure is SHORT_ONLY)
    Entry Short: [describe short entry condition]
{% endif %}
{% if structure.exit_indicator %}
    Exit: Indicator-based close signal when [describe exit condition]
{% endif %}
{% if structure.time_exit %}
    Time Exit: Close after {{ "{{ exit_bars }}" }} bars
{% endif %}
    """

    leverage = {{ "__LEVERAGE__" }}  # Will be replaced by system

    # Indicator columns added by calculate_indicators()
    # Used for lookahead bias detection
    indicator_columns = ['atr']  # ADD YOUR INDICATOR NAMES HERE

    def __init__(self, params: dict = None):
        super().__init__(params)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Pre-calculate ALL indicators on the dataframe.

        This method is called ONCE before signal generation. All indicator
        calculations should happen here, not in generate_signal().

        IMPORTANT:
        - Always return df.copy() to avoid modifying the original
        - Use only lookback operations (no center=True, no shift(-N))
        - Update indicator_columns with all column names you add
        """
        df = df.copy()

        # ATR for stop loss calculation (always needed)
        df['atr'] = ta.ATR(df['high'], df['low'], df['close'], timeperiod=14)

        # YOUR INDICATOR CALCULATIONS HERE
        # Example: df['rsi'] = ta.RSI(df['close'], timeperiod={{ "{{ indicator_period }}" }})

        return df

    def generate_signal(self, df: pd.DataFrame, symbol: str = None) -> Signal | None:
        """
        Generate signal from DataFrame with pre-calculated indicators.

        IMPORTANT: DO NOT calculate indicators here - they are already in df.
        Only read values using iloc[-1] and apply entry/exit logic.
        """
        min_bars = 100
        if len(df) < min_bars:
            return None

        # ============================================
        # READ PRE-CALCULATED INDICATOR VALUES
        # Use iloc[-1] to get current bar values
        # ============================================

        current_price = df['close'].iloc[-1]
        current_atr = df['atr'].iloc[-1]

        if pd.isna(current_atr) or current_atr <= 0:
            return None

        # YOUR INDICATOR VALUE READS HERE
        # Example: current_rsi = df['rsi'].iloc[-1]

        # ============================================
{% if structure.exit_indicator %}
        # EXIT CONDITION (indicator-based)
        # Check exit BEFORE entry to close existing positions first
        # ============================================

        exit_condition = False  # YOUR EXIT LOGIC using {{ "{{ exit_threshold }}" }}

        if exit_condition:
            return Signal(
                direction='close',
                reason="Exit: [describe why exiting]"
            )

        # ============================================
{% endif %}
        # ENTRY CONDITIONS
        # ============================================

{% if structure.entry_long %}
        entry_long = False  # YOUR LONG ENTRY using {{ "{{ entry_threshold }}" }}
{% endif %}
{% if structure.entry_short %}
        entry_short = False  # YOUR SHORT ENTRY using {{ "{{ entry_threshold }}" }}
{% endif %}

{% if structure.entry_long %}
        if entry_long:
            return Signal(
                direction='long',
                leverage=self.leverage,
{% if structure.trailing_stop %}
                sl_type=StopLossType.TRAILING,
                trailing_stop_pct={{ "{{ trailing_stop_pct }}" }},
                trailing_activation_pct={{ "{{ trailing_activation_pct }}" }},
{% else %}
                sl_type=StopLossType.ATR,
                atr_stop_multiplier={{ "{{ atr_multiplier }}" }},
{% endif %}
{% if structure.take_profit %}
                tp_type=TakeProfitType.RR_RATIO,
                rr_ratio=2.0,
{% endif %}
{% if structure.time_exit %}
                exit_type=ExitType.TIME_BASED,
                exit_after_bars={{ "{{ exit_bars }}" }},
{% endif %}
                reason="Long: [describe entry reason]"
            )

{% endif %}
{% if structure.entry_short %}
        if entry_short:
            return Signal(
                direction='short',
                leverage=self.leverage,
{% if structure.trailing_stop %}
                sl_type=StopLossType.TRAILING,
                trailing_stop_pct={{ "{{ trailing_stop_pct }}" }},
                trailing_activation_pct={{ "{{ trailing_activation_pct }}" }},
{% else %}
                sl_type=StopLossType.ATR,
                atr_stop_multiplier={{ "{{ atr_multiplier }}" }},
{% endif %}
{% if structure.take_profit %}
                tp_type=TakeProfitType.RR_RATIO,
                rr_ratio=2.0,
{% endif %}
{% if structure.time_exit %}
                exit_type=ExitType.TIME_BASED,
                exit_after_bars={{ "{{ exit_bars }}" }},
{% endif %}
                reason="Short: [describe entry reason]"
            )

{% endif %}
        return None
```

=== PARAMETERS SCHEMA ===

After the code, provide a JSON schema with parameter values.
Be CREATIVE with the values - don't just copy the examples below!

```json
{
  "indicator_period": {"type": "int", "values": [YOUR_CHOICES]},
  "entry_threshold": {"type": "int_or_float", "values": [YOUR_CHOICES]},
{% if structure.exit_indicator %}
  "exit_threshold": {"type": "int_or_float", "values": [YOUR_CHOICES]},
{% endif %}
{% if structure.trailing_stop %}
  "trailing_stop_pct": {"type": "float", "values": [YOUR_CHOICES]},
  "trailing_activation_pct": {"type": "float", "values": [YOUR_CHOICES]}{% if structure.time_exit %},
  "exit_bars": {"type": "int", "values": [YOUR_CHOICES]}{% endif %}
{% else %}
  "atr_multiplier": {"type": "float", "values": [YOUR_CHOICES]}{% if structure.time_exit %},
  "exit_bars": {"type": "int", "values": [YOUR_CHOICES]}{% endif %}
{% endif %}

}
```

GUIDELINES for parameter values:
- indicator_period: typically 5-50 for oscillators, 10-200 for MAs
- entry_threshold: depends on indicator (RSI: 20-40, Z-score: 1.5-3.0, etc.)
{% if structure.trailing_stop %}
- trailing_stop_pct: MUST be 0.02-0.05 (2%-5% trail distance)
  * WARNING: Values below 2% cause overfitting - great backtest but poor live results!
  * Reason: Live has spread, slippage, latency that backtest doesn't capture
  * Recommended: 0.025-0.04 (2.5%-4%) for robust performance
- trailing_activation_pct: MUST be 0.01-0.03 (1%-3% profit before trailing activates)
  * WARNING: Values below 1% activate too early before trend is confirmed
  * Recommended: 0.015-0.025 (1.5%-2.5%) for better trend confirmation
{% else %}
- atr_multiplier: typically 1.0-5.0 (tighter = more trades, wider = fewer trades)
{% endif %}
{% if structure.time_exit %}
- exit_bars: MUST be appropriate for {{ timeframe }} timeframe:
{% if timeframe == '15m' %}
  * 15m: use 8-24 bars (2-6 hours holding time)
{% elif timeframe == '30m' %}
  * 30m: use 6-16 bars (3-8 hours holding time)
{% elif timeframe == '1h' %}
  * 1h: use 4-12 bars (4-12 hours holding time)
{% elif timeframe == '4h' %}
  * 4h: use 3-6 bars (12h-1 day holding time)
{% elif timeframe == '1d' %}
  * 1d: use 2-5 bars (2-5 days holding time)
{% else %}
  * Use reasonable values for {{ timeframe }} (avoid holding more than 1-2 days)
{% endif %}
{% endif %}
- DO NOT include "leverage" - it's assigned by the system
- Aim for 3-5 values per parameter

=== FINAL CHECKLIST ===

Before generating, verify:
{% if structure.entry_long and not structure.entry_short %}
[ ] ONLY long entries (NO entry_short, NO direction='short')
{% elif structure.entry_short and not structure.entry_long %}
[ ] ONLY short entries (NO entry_long, NO direction='long')
{% else %}
[ ] Both long AND short entries present
{% endif %}
{% if structure.trailing_stop %}
[ ] Stop loss uses sl_type=StopLossType.TRAILING with trailing_stop_pct and trailing_activation_pct
{% else %}
[ ] Stop loss is ALWAYS set (sl_type required)
{% endif %}
{% if structure.take_profit %}
[ ] Take profit IS set (tp_type required)
{% else %}
[ ] Take profit is NOT set (no tp_type)
{% endif %}
{% if structure.exit_indicator %}
[ ] Exit indicator generates Signal(direction='close')
{% else %}
[ ] NO direction='close' signals
{% endif %}
{% if structure.time_exit %}
[ ] Time exit with exit_after_bars parameter
{% else %}
[ ] NO exit_after_bars parameter
{% endif %}
[ ] All Jinja2 placeholders use double braces {{ "{{ }}" }}
[ ] Parameter schema matches placeholders in code (NO leverage!)
[ ] 50-200 total parameter combinations
[ ] leverage = {{ "__LEVERAGE__" }} is in class body (will be replaced by system)
[ ] TWO-PHASE APPROACH: calculate_indicators() pre-calculates ALL indicators
[ ] generate_signal() ONLY reads pre-calculated values (no ta.XXX calls!)
[ ] indicator_columns class attribute lists all indicator column names

Generate the complete parameterized template now.

REQUIREMENTS:
1. Be STRICT with structure compliance (entry direction, SL, TP, exits)
2. Be CREATIVE with entry logic - choose from the 8 categories above
3. In the docstring, specify which ENTRY LOGIC CATEGORY you chose
4. Parameters schema must match the placeholders in your code
5. Aim for 50-200 total parameter combinations
6. Do NOT include leverage in parameters - use {{ "__LEVERAGE__" }} placeholder
