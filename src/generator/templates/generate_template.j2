You are an expert quantitative trader. Generate a PARAMETERIZED strategy template following the EXACT structure specified below.

=== STRATEGY SPECIFICATION ===

Strategy Type: {{ strategy_type }}
Timeframe: {{ timeframe }}
Template ID: {{ template_id }}

=== MANDATORY STRUCTURE ===

This template MUST follow this EXACT structure. Do NOT add or remove components.

{% if structure.entry_long and structure.entry_short %}
ENTRY: BIDIRECTIONAL (both long AND short entries required)
{% elif structure.entry_long %}
ENTRY: LONG ONLY (generate ONLY long entries, NO short entries)
{% else %}
ENTRY: SHORT ONLY (generate ONLY short entries, NO long entries)
{% endif %}

{% if structure.trailing_stop %}
STOP LOSS: TRAILING (sl_type=StopLossType.TRAILING)
- Uses trailing_stop_pct: distance from high water mark
- Uses trailing_activation_pct: profit threshold before trailing activates
{% else %}
STOP LOSS: ALWAYS REQUIRED (use percentage-based)
{% endif %}

{% if structure.take_profit %}
TAKE PROFIT: REQUIRED (use percentage-based)
{% else %}
TAKE PROFIT: DO NOT USE (tp_type must NOT be set)
{% endif %}

{% if structure.time_exit %}
TIME EXIT: REQUIRED
- Include exit_after_bars={{ "{{ exit_bars }}" }} parameter
{% else %}
TIME EXIT: DO NOT USE
{% endif %}

=== CRITICAL: VECTORIZED BACKTEST REQUIREMENTS ===

The strategy MUST support vectorized backtesting:

1. calculate_indicators() MUST populate 'entry_signal' boolean column
2. Class attributes MUST be defined: direction, sl_pct, tp_pct, exit_after_bars, signal_column
3. generate_signal() is ONLY for live execution (reads entry_signal[-1])

The backtester reads entry_signal as a numpy array - NO per-bar loops!

=== STRATEGY TYPE GUIDANCE ===

{% if strategy_type == 'MOM' %}
MOMENTUM Strategy:
- Identify trending moves using momentum state (not crossover events)
- RSI above/below threshold, MACD histogram positive/negative, ROC direction
- Entry when momentum STATE is favorable (e.g., RSI > 50 AND MACD > 0)
{% elif strategy_type == 'REV' %}
MEAN REVERSION Strategy:
- Identify overbought/oversold extreme conditions
- RSI extremes, Bollinger Band touches, deviation from mean
- Entry on bounces from statistical extremes
{% elif strategy_type == 'TRN' %}
TREND FOLLOWING Strategy:
- Ride established trends using trend STATE indicators
- EMA alignment (fast > slow = uptrend), ADX > threshold, price above MA
- Entry when trend STATE is confirmed (e.g., close > EMA50 AND ADX > 25)
{% elif strategy_type == 'BRE' %}
BREAKOUT Strategy:
- Trade range/consolidation breakouts
- Support/resistance levels, Donchian channels, N-bar highs/lows
- Entry on volume-confirmed breakouts
{% elif strategy_type == 'VOL' %}
VOLATILITY Strategy:
- Trade volatility expansions and contractions
- Bollinger Band squeeze, ATR breakouts, Keltner channels
- Entry on volatility expansion from squeeze
{% elif strategy_type == 'SCA' %}
SCALPING Strategy:
- Quick entries and exits on minor price movements
- Short-term oscillators, micro-trends, fast EMAs
- Tight stops, quick profits
{% endif %}

{% if main_indicators %}
=== MANDATORY INDICATORS (IndicatorCombinator) ===

You MUST use these SPECIFIC indicators in your strategy. Do NOT use other indicators.

MAIN INDICATORS (for signal generation):
{% for ind in main_indicators %}
- {{ ind }}
{% endfor %}

{% if filter_indicators %}
FILTER INDICATORS (for entry confirmation):
{% for ind in filter_indicators %}
- {{ ind }}
{% endfor %}

Your entry_signal logic MUST:
1. Use ALL main indicators ({{ main_indicators | join(', ') }}) for signal generation
2. Use filter indicators ({{ filter_indicators | join(', ') }}) as additional entry conditions
3. Combine them with logical AND/OR operations
{% else %}
Use ONLY the main indicators above. Do not add filter conditions.
{% endif %}

Example for main={{ main_indicators }}:
```python
# Calculate assigned indicators
{% for ind in main_indicators %}
df['{{ ind }}'] = ta.{{ ind | upper }}(df['close'], timeperiod={{ "{{ indicator_period }}" }})
{% endfor %}
{% if filter_indicators %}
{% for ind in filter_indicators %}
df['{{ ind }}'] = ta.{{ ind | upper }}(df['high'], df['low'], df['close'], timeperiod=14)
{% endfor %}
{% endif %}

# Entry signal using assigned indicators
entry_condition = (df['{{ main_indicators[0] }}'] > {{ "{{ entry_threshold }}" }})
{% if main_indicators | length > 1 %}
entry_condition = entry_condition & (df['{{ main_indicators[1] }}'] > 0)
{% endif %}
{% if filter_indicators %}
# Apply filter
entry_condition = entry_condition & (df['{{ filter_indicators[0] }}'] > 25)
{% endif %}
df['entry_signal'] = entry_condition
```

{% else %}
=== ENTRY LOGIC CATEGORIES ===

Choose ONE primary category for your entry logic. This creates diversity across templates.
{% endif %}

**1. INDICATOR-BASED** (Traditional TA)
   Common oscillators: RSI, MACD, Stochastic, CCI, Williams %R, MFI
   Moving averages: EMA, SMA, WMA, DEMA, TEMA, KAMA
   Bands/Channels: BBANDS (Bollinger), Keltner, Donchian
   Trend: ADX, Supertrend, Parabolic SAR

   Example: `rsi = ta.RSI(df['close'], {{ "{{ indicator_period }}" }})`

**2. PRICE ACTION** (No indicators, pure price)
   - Price above/below N-bar high or low (state, not breakout event)
   - Higher highs / lower lows sequence
   - Example: `above_range = df['close'] > df['high'].rolling({{ "{{ lookback }}" }}).max().shift(1)`

**3. STRUCTURE-BASED** (Market structure)
   - Support/resistance levels (swing highs/lows)
   - Donchian channels
   - Example: `swing_low = df['low'].rolling({{ "{{ lookback }}" }}).min()`

**4. VOLUME-BASED** (Volume as primary trigger)
   - Volume spike entry (volume > N x average)
   - Example: `vol_spike = df['volume'] > df['volume'].rolling(20).mean() * {{ "{{ volume_mult }}" }}`

=== CRITICAL: STATE-BASED vs CROSSOVER LOGIC ===

Your entry logic MUST use STATE-BASED conditions, NOT crossover events.

**WRONG - CROSSOVER (too rare, may produce 0 signals in 30 days):**
```python
# This requires a TRANSITION to happen at exactly this bar
ema_fast_prev = df['ema_fast'].shift(1)
ema_slow_prev = df['ema_slow'].shift(1)
crossover = (ema_fast_prev <= ema_slow_prev) & (df['ema_fast'] > df['ema_slow'])
df['entry_signal'] = crossover  # BAD: may be False for entire holdout period!
```

**CORRECT - STATE-BASED (reliable, regular signals):**
```python
# This checks CURRENT CONDITIONS - triggers whenever state is true
trend_up = df['ema_fast'] > df['ema_slow']
momentum_strong = df['rsi'] > 50
df['entry_signal'] = trend_up & momentum_strong  # GOOD: signals on any matching bar
```

**RULES:**
1. NEVER use shift(1) to compare previous vs current values for entry detection
2. Check CURRENT indicator values, not transitions between bars
3. Combine 2-3 state conditions for filtering (e.g., trend + momentum + volume)
4. Entry should trigger on ANY bar meeting conditions, not on specific events

**WHY THIS MATTERS:**
- Crossover events happen ~1-2 times per month
- Your strategy is validated on 30-day holdout period
- If crossover doesn't happen in holdout → 0 trades → strategy rejected
- State-based logic triggers regularly → meaningful validation

=== PARAMETERIZATION RULES ===

Your code MUST use Jinja2 placeholders for ALL variable parameters.
Use double braces: {{ "{{ parameter_name }}" }}

REQUIRED PARAMETERS (include ALL of these):
- {{ "{{ indicator_period }}" }} - Main indicator lookback period
- {{ "{{ entry_threshold }}" }} - Entry trigger threshold
- {{ "{{ sl_pct }}" }} - Stop loss percentage (e.g., 0.02 = 2%)
- {{ "{{ tp_pct }}" }} - Take profit percentage (e.g., 0.03 = 3%)
{% if structure.time_exit %}
- {{ "{{ exit_bars }}" }} - Number of bars for time-based exit
{% endif %}

NOTE: Do NOT include "leverage" as a parameter - it will be assigned automatically by the system.

=== CRITICAL: NO LOOKAHEAD BIAS (AUTOMATIC REJECTION) ===

YOUR CODE WILL BE AUTOMATICALLY REJECTED IF IT CONTAINS:
- rolling(center=True) <-- NEVER USE THIS, IT LOOKS INTO THE FUTURE
- shift(-N) where N > 0 <-- NEVER USE NEGATIVE SHIFT
- Any other access to future data

CORRECT PATTERNS (use these instead):
- rolling(N) with NO center parameter (defaults to center=False which is correct)
- rolling(window=N) with NO center parameter
- shift(N) where N >= 0 (positive or zero only)

EXAMPLE:
# WRONG - WILL BE REJECTED:
df['sma'] = df['close'].rolling(20, center=True).mean()

# CORRECT - WILL BE ACCEPTED:
df['sma'] = df['close'].rolling(20).mean()

=== CODE TEMPLATE ===

CRITICAL: The strategy uses a VECTORIZED approach:
1. calculate_indicators(df) - Pre-calculate ALL indicators AND entry_signal column
2. Backtester reads entry_signal as numpy array (no per-bar loops)
3. generate_signal(df) - ONLY for live execution (reads entry_signal[-1])

```python
import pandas as pd
import numpy as np
import talib as ta
from src.strategies.base import StrategyCore, Signal, StopLossType, TakeProfitType, ExitType


class Strategy_{{ strategy_type }}_{{ template_id }}(StrategyCore):
    """
    {{ strategy_type }} strategy template for {{ timeframe }} timeframe
    Structure: {{ structure.name }}

    Entry Logic Category: [SPECIFY WHICH CATEGORY FROM THE 8 ABOVE]

    [DESCRIBE YOUR ENTRY LOGIC IN 2-3 SENTENCES]

    Parameters:
    - indicator_period: Main indicator lookback
    - entry_threshold: Entry trigger level
    - sl_pct: Stop loss percentage
    - tp_pct: Take profit percentage
{% if structure.time_exit %}
    - exit_bars: Time-based exit after N bars
{% endif %}

{% if structure.entry_long and structure.entry_short %}
    Entry Long: [describe long entry condition]
    Entry Short: [describe short entry condition]
{% elif structure.entry_long %}
    Entry Long: [describe long entry condition]
    Entry Short: NOT GENERATED (structure is LONG_ONLY)
{% else %}
    Entry Long: NOT GENERATED (structure is SHORT_ONLY)
    Entry Short: [describe short entry condition]
{% endif %}
{% if structure.time_exit %}
    Time Exit: Close after {{ "{{ exit_bars }}" }} bars
{% endif %}
    """

    # =========================================================================
    # STRATEGY PARAMETERS (read by backtester for vectorized execution)
    # =========================================================================
{% if structure.entry_long %}
    direction = 'long'
{% else %}
    direction = 'short'
{% endif %}
    sl_pct = {{ "{{ sl_pct }}" }}
    tp_pct = {{ "{{ tp_pct }}" }}
    leverage = {{ "__LEVERAGE__" }}  # Will be replaced by system
{% if structure.time_exit %}
    exit_after_bars = {{ "{{ exit_bars }}" }}
{% else %}
    exit_after_bars = 20
{% endif %}
    signal_column = 'entry_signal'

    # Indicator columns added by calculate_indicators()
    indicator_columns = ['atr', 'entry_signal']  # ADD YOUR INDICATOR NAMES HERE

    def __init__(self, params: dict = None):
        super().__init__(params)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Pre-calculate ALL indicators AND entry_signal on the dataframe.

        CRITICAL: This method MUST populate 'entry_signal' boolean column.
        The backtester reads this column as a numpy array for vectorized execution.

        IMPORTANT:
        - Always return df.copy() to avoid modifying the original
        - Use only lookback operations (no center=True, no shift(-N))
        - entry_signal must be a boolean Series (True = entry, False = no entry)
        """
        df = df.copy()

        # ATR for reference (may be used in entry logic)
        df['atr'] = ta.ATR(df['high'], df['low'], df['close'], timeperiod=14)

        # YOUR INDICATOR CALCULATIONS HERE
        # Example: df['rsi'] = ta.RSI(df['close'], timeperiod={{ "{{ indicator_period }}" }})

        # ============================================
        # ENTRY SIGNAL (VECTORIZED - CRITICAL!)
        # Must be a boolean column: True = entry signal, False = no signal
        # ============================================

{% if structure.entry_long %}
        # Long entry condition (vectorized)
        entry_condition = False  # YOUR VECTORIZED LONG ENTRY LOGIC using {{ "{{ entry_threshold }}" }}
        # Example: entry_condition = df['rsi'] < {{ "{{ entry_threshold }}" }}
{% else %}
        # Short entry condition (vectorized)
        entry_condition = False  # YOUR VECTORIZED SHORT ENTRY LOGIC using {{ "{{ entry_threshold }}" }}
        # Example: entry_condition = df['rsi'] > {{ "{{ entry_threshold }}" }}
{% endif %}

        df['entry_signal'] = entry_condition

        return df

    def generate_signal(self, df: pd.DataFrame, symbol: str = None) -> Signal | None:
        """
        Generate signal for LIVE execution only.

        For BACKTEST: The backtester reads entry_signal column directly (vectorized).
        For LIVE: This method reads entry_signal[-1] and returns a Signal object.

        DO NOT calculate indicators here - they are already in df from calculate_indicators().
        """
        min_bars = 100
        if len(df) < min_bars:
            return None

        # Read pre-calculated entry signal
        if not df['entry_signal'].iloc[-1]:
            return None

        return Signal(
            direction=self.direction,
            leverage=self.leverage,
            sl_type=StopLossType.PERCENTAGE,
            sl_pct=self.sl_pct,
{% if structure.take_profit %}
            tp_type=TakeProfitType.PERCENTAGE,
            tp_pct=self.tp_pct,
{% endif %}
{% if structure.time_exit %}
            exit_type=ExitType.TIME_BASED,
            exit_after_bars=self.exit_after_bars,
{% endif %}
            reason="{{ strategy_type }}: [describe entry reason]"
        )
```

=== PARAMETERS SCHEMA ===

After the code, provide a JSON schema with parameter values.
Be CREATIVE with the values - don't just copy the examples below!

```json
{
  "indicator_period": {"type": "int", "values": [YOUR_CHOICES]},
  "entry_threshold": {"type": "int_or_float", "values": [YOUR_CHOICES]},
  "sl_pct": {"type": "float", "values": [0.02, 0.03, 0.04, 0.05]},
  "tp_pct": {"type": "float", "values": [0.03, 0.04, 0.05, 0.06]}{% if structure.time_exit %},
  "exit_bars": {"type": "int", "values": [YOUR_CHOICES]}{% endif %}

}
```

GUIDELINES for parameter values:
- indicator_period: typically 5-50 for oscillators, 10-200 for MAs
- entry_threshold: depends on indicator (RSI: 20-40, Z-score: 1.5-3.0, etc.)
- sl_pct: 0.02-0.05 (2%-5% stop loss)
- tp_pct: 0.03-0.08 (3%-8% take profit)
{% if structure.time_exit %}
- exit_bars: MUST be appropriate for {{ timeframe }} timeframe:
{% if timeframe == '15m' %}
  * 15m: use 8-24 bars (2-6 hours holding time)
{% elif timeframe == '30m' %}
  * 30m: use 6-16 bars (3-8 hours holding time)
{% elif timeframe == '1h' %}
  * 1h: use 4-12 bars (4-12 hours holding time)
{% elif timeframe == '4h' %}
  * 4h: use 3-6 bars (12h-1 day holding time)
{% elif timeframe == '1d' %}
  * 1d: use 2-5 bars (2-5 days holding time)
{% else %}
  * Use reasonable values for {{ timeframe }} (avoid holding more than 1-2 days)
{% endif %}
{% endif %}
- DO NOT include "leverage" - it's assigned by the system
- Aim for 3-5 values per parameter

=== FINAL CHECKLIST ===

Before generating, verify:
{% if structure.entry_long and not structure.entry_short %}
[ ] direction = 'long' (class attribute)
[ ] ONLY long entries in entry_signal logic
{% elif structure.entry_short and not structure.entry_long %}
[ ] direction = 'short' (class attribute)
[ ] ONLY short entries in entry_signal logic
{% else %}
[ ] Both directions supported
{% endif %}
[ ] sl_pct class attribute uses {{ "{{ sl_pct }}" }} placeholder
[ ] tp_pct class attribute uses {{ "{{ tp_pct }}" }} placeholder
[ ] signal_column = 'entry_signal' is set
[ ] calculate_indicators() populates 'entry_signal' column (VECTORIZED!)
[ ] entry_signal is a boolean Series (True/False)
[ ] generate_signal() ONLY reads entry_signal[-1] (no calculation!)
[ ] leverage = {{ "__LEVERAGE__" }} is in class body (will be replaced by system)
[ ] All Jinja2 placeholders use double braces {{ "{{ }}" }}
[ ] Parameter schema includes sl_pct and tp_pct
[ ] 50-200 total parameter combinations

=== SELF-CHECK: ENTRY LOGIC VALIDATION ===

Before generating, verify your entry_signal logic:

[ ] Uses STATE-BASED conditions (e.g., RSI < 30, EMA_fast > EMA_slow)
[ ] Does NOT use shift(1) comparisons for entry detection (crossover pattern)
[ ] Combines 2-3 conditions for filtering
[ ] Expected to trigger on ~5-20% of bars (not <1%)

If your entry logic requires a TRANSITION (previous vs current), REWRITE IT as a STATE check.

Generate the complete parameterized template now.

REQUIREMENTS:
1. Be STRICT with structure compliance
2. Be CREATIVE with entry logic - choose from the categories above
3. entry_signal MUST be calculated VECTORIZED (no loops, use pandas operations)
4. Parameters schema must match the placeholders in your code
5. Do NOT include leverage in parameters - use {{ "__LEVERAGE__" }} placeholder
