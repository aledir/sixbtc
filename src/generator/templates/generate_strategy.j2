You are an expert quantitative trader specialized in cryptocurrency perpetual futures trading.

Generate a complete, production-ready StrategyCore class for automated trading.

=== STRICT REQUIREMENTS ===

1. INHERITANCE: Class MUST inherit from StrategyCore
2. METHOD: MUST implement generate_signal(self, df: pd.DataFrame) -> Signal | None
3. PURITY: Function MUST be PURE (no state mutation, no side effects)
4. NO LOOKAHEAD BIAS - Use ONLY past data:
   - ALLOWED: df['close'].rolling(10).max()
   - FORBIDDEN: df['close'].rolling(10, center=True).max()
   - ALLOWED: df['close'].iloc[-1]
   - FORBIDDEN: df['close'].shift(-1)
   - FORBIDDEN: Any negative shift values
   - FORBIDDEN: Future references

=== STRATEGY SPECIFICATION ===

Strategy Type: {{ strategy_type }}
Timeframe: {{ timeframe }}
Target ID: {{ strategy_id }}

{% if patterns %}
=== VALIDATED PATTERNS FROM PATTERN-DISCOVERY ===

You have access to these proven patterns with real backtest results:

{% for pattern in patterns %}
Pattern {{ loop.index }}: {{ pattern.name }}
  Formula: {{ pattern.formula }}
  Performance:
    - Edge: {{ "%.2f"|format(pattern.test_edge) }}%
    - Win Rate: {{ "%.1f"|format(pattern.test_win_rate * 100) }}%
    - Sharpe: {{ "%.2f"|format(pattern.test_sharpe) }}
    - Total Trades: {{ pattern.test_trades }}
  Direction: {{ pattern.target_direction }}
  Quality Score: {{ "%.2f"|format(pattern.quality_score) }}

{% endfor %}

PATTERN COMBINATION STRATEGIES:
- You may combine 2-3 patterns using AND logic for stronger signals
- Prefer patterns with same target_direction
- Higher quality_score = more reliable
{% else %}
=== NO PATTERNS PROVIDED ===

Create a custom strategy using standard technical indicators:
- Momentum: RSI, MACD, Stochastic, ADX
- Trend: EMA, SMA, Supertrend, Ichimoku
- Volume: Volume Profile, OBV, VWAP
- Volatility: Bollinger Bands, ATR, Keltner Channels
{% endif %}

=== STRATEGY TYPES GUIDANCE ===

{% if strategy_type == 'MOM' %}
MOMENTUM Strategy:
- Identify trending moves early
- Use RSI, MACD, or momentum oscillators
- Entry on breakouts or momentum confirmation
- Exit on momentum exhaustion
{% elif strategy_type == 'REV' %}
MEAN REVERSION Strategy:
- Identify overbought/oversold conditions
- Use RSI extremes, Bollinger Bands
- Entry on bounces from extremes
- Exit when price returns to mean
{% elif strategy_type == 'TRN' %}
TREND FOLLOWING Strategy:
- Ride established trends
- Use moving average crossovers, ADX
- Entry on pullbacks in strong trends
- Exit on trend reversal signals
{% elif strategy_type == 'BRE' %}
BREAKOUT Strategy:
- Trade range breakouts
- Use support/resistance, consolidation patterns
- Entry on volume-confirmed breakouts
- Exit on false breakout or target hit
{% else %}
CUSTOM Strategy:
- Combine multiple approaches
- Use creative indicator combinations
- Focus on edge and risk management
{% endif %}

=== OUTPUT FORMAT ===

Generate ONLY the Python code block below. NO explanations before or after.

```python
import pandas as pd
import numpy as np
import talib as ta
from src.strategies.base import StrategyCore, Signal


class Strategy_{{ strategy_type }}_{{ strategy_id }}(StrategyCore):
    """
    {{ strategy_type }} strategy for {{ timeframe }} timeframe

    Entry: [Describe entry conditions clearly]
    Exit: ATR-based stop loss and take profit
    Risk/Reward: 1.5:1 minimum

    {% if patterns %}
    Based on patterns:
    {% for pattern in patterns[:3] %}
    - {{ pattern.name }}
    {% endfor %}
    {% endif %}
    """

    def __init__(self, params: dict = None):
        """Initialize strategy with parameters"""
        super().__init__(params)

        # Strategy parameters (can be optimized)
        # Example: self.rsi_period = self.params.get('rsi_period', 14)

    def generate_signal(self, df: pd.DataFrame) -> Signal | None:
        """
        Generate trading signal from OHLCV data

        Args:
            df: OHLCV DataFrame with columns ['open', 'high', 'low', 'close', 'volume']

        Returns:
            Signal object if conditions met, None otherwise
        """
        # Minimum data requirement
        min_bars = 100  # Adjust based on indicator needs
        if len(df) < min_bars:
            return None

        # ======================
        # CALCULATE INDICATORS
        # ======================
        # Use ONLY past data (no lookahead bias)

        # Example: RSI
        # rsi = ta.RSI(df['close'], timeperiod=14)
        # current_rsi = rsi.iloc[-1]

        # Example: ATR (for stop loss calculation)
        atr = ta.ATR(df['high'], df['low'], df['close'], timeperiod=14)
        current_atr = atr.iloc[-1]
        current_price = df['close'].iloc[-1]

        # ======================
        # YOUR LOGIC HERE
        # ======================
        # Implement your entry conditions based on:
        # - Technical indicators
        # - Pattern conditions (if provided)
        # - Market structure

        # Example entry condition (REPLACE WITH YOUR LOGIC):
        # entry_long = (current_rsi < 30)  # Oversold
        # entry_short = (current_rsi > 70)  # Overbought

        # ======================
        # ENTRY SIGNALS
        # ======================

        # LONG entry
        # if entry_long:
        #     return Signal(
        #         direction='long',
        #         atr_stop_multiplier=2.0,
        #         atr_take_multiplier=3.0,
        #         reason=f"Long signal: RSI oversold at {current_rsi:.2f}"
        #     )

        # SHORT entry
        # if entry_short:
        #     return Signal(
        #         direction='short',
        #         atr_stop_multiplier=2.0,
        #         atr_take_multiplier=3.0,
        #         reason=f"Short signal: RSI overbought at {current_rsi:.2f}"
        #     )

        # No signal
        return None
```

=== IMPORTANT NOTES ===

1. DO NOT use any lookahead bias (no center=True, no negative shifts)
2. All indicators must use ONLY historical data
3. Use iloc[-1] to get current values, iloc[-2] for previous bar
4. ATR-based stops are preferred (more adaptive to volatility)
5. Include clear reason string for debugging
6. Keep logic simple and clear (avoid over-complexity)
7. Test for minimum data length before calculating indicators
8. Return None if no valid signal

Generate the complete code now.
