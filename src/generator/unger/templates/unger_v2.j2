"""
Unger Strategy v2: {{ entry.name }}
Timeframe: {{ timeframe }}
Direction: {{ entry.direction }}
Exit Mechanism: {{ exit_mechanism.name }}
Generated: {{ generated_at }}
"""

from src.strategies.base import StrategyCore, Signal, StopLossType, TakeProfitType
import pandas as pd
import numpy as np


class {{ class_name }}(StrategyCore):
    """
    Entry: {{ entry.name }} ({{ entry.category }})
    Filters: {{ filters | length }}
    Exit: {{ exit_mechanism.description }}
    SL: {{ sl_config.name }}
    {% if tp_config %}TP: {{ tp_config.name }}{% endif %}
    {% if trailing %}Trailing: {{ trailing.name }}{% endif %}
    """

    # Direction (use entry's direction, not blueprint-level)
    direction = '{{ entry.direction | lower }}'

    # Indicator columns for lookahead test
    indicator_columns = [
        {% if 'RSI' in entry.indicators_used or (exit_condition and 'RSI' in exit_condition.indicators_used) %}'rsi',{% endif %}
        {% if 'MA' in entry.indicators_used %}{% if entry_params.get('fast') %}'ma_fast', 'ma_slow',{% else %}'ma',{% endif %}{% endif %}
        {% if 'EMA' in entry.indicators_used %}'ema_fast', 'ema_slow',{% endif %}
        {% if 'MACD' in entry.indicators_used or (exit_condition and 'MACD' in exit_condition.indicators_used) %}'macd', 'macd_signal',{% endif %}
        {% if 'BB' in entry.indicators_used %}'bb_mid', 'bb_std', 'bb_upper', 'bb_lower',{% endif %}
        {% if 'ATR' in entry.indicators_used or sl_config.sl_type == 'atr' or (tp_config and tp_config.tp_type == 'atr') %}'atr',{% endif %}
        {% if 'STOCH' in entry.indicators_used %}'stoch_k', 'stoch_d',{% endif %}
        {% if 'CCI' in entry.indicators_used %}'cci',{% endif %}
        {% if 'ADX' in entry.indicators_used or (exit_condition and 'ADX' in exit_condition.indicators_used) %}'adx',{% endif %}
        {% if 'ROC' in entry.indicators_used or (exit_condition and 'ROC' in exit_condition.indicators_used) %}'roc',{% endif %}
    ]

    # Parametric placeholders (expanded by backtester)
    SL_PCT = {{ sl_params.get('sl_pct', 0.02) }}
    TP_PCT = {{ tp_params.get('tp_pct', 0.04) if tp_params else 0.04 }}
    LEVERAGE = 1
    LOOKBACK = {{ entry.lookback_required }}
    {% if exit_params and exit_params.get('N') %}
    exit_after_bars = {{ exit_params.get('N', 20) }}
    {% else %}
    exit_after_bars = 0  # No time-based exit
    {% endif %}

    # Stop Loss config
    {% if sl_config.sl_type == 'atr' %}
    sl_type = StopLossType.ATR
    atr_stop_multiplier = {{ sl_params.get('atr_multiplier', 2.0) }}
    {% elif sl_config.sl_type == 'structure' %}
    sl_type = StopLossType.STRUCTURE
    structure_lookback = {{ sl_params.get('lookback', 10) }}
    {% elif sl_config.sl_type == 'trailing' %}
    sl_type = StopLossType.TRAILING
    trailing_stop_pct = {{ sl_params.get('trailing_pct', 0.02) }}
    trailing_activation_pct = {{ sl_params.get('activation_pct', 0.01) }}
    {% else %}
    sl_type = StopLossType.PERCENTAGE
    {% endif %}

    # Take Profit config
    {% if tp_config %}
    {% if tp_config.tp_type == 'atr' %}
    tp_type = TakeProfitType.ATR
    atr_take_multiplier = {{ tp_params.get('atr_multiplier', 3.0) }}
    {% elif tp_config.tp_type == 'rr_ratio' %}
    tp_type = TakeProfitType.RR_RATIO
    rr_ratio = {{ tp_params.get('rr_ratio', 2.0) }}
    {% else %}
    tp_type = TakeProfitType.PERCENTAGE
    {% endif %}
    {% else %}
    tp_type = TakeProfitType.PERCENTAGE
    {% endif %}

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Pre-calculate indicators for vectorized backtesting."""
        df = df.copy()

        {% if 'RSI' in entry.indicators_used or (exit_condition and 'RSI' in exit_condition.indicators_used) %}
        # RSI
        delta = df['close'].diff()
        gain = delta.clip(lower=0).rolling(14).mean()
        loss = (-delta.clip(upper=0)).rolling(14).mean()
        df['rsi'] = 100 - (100 / (1 + gain / (loss + 1e-10)))
        {% endif %}

        {% if 'MA' in entry.indicators_used %}
        # Moving Averages
        {% if entry_params.get('fast') %}
        df['ma_fast'] = df['close'].rolling({{ entry_params.get('fast', 10) }}).mean()
        df['ma_slow'] = df['close'].rolling({{ entry_params.get('slow', 20) }}).mean()
        {% elif entry_params.get('N') %}
        df['ma'] = df['close'].rolling({{ entry_params.get('N', 20) }}).mean()
        {% else %}
        df['ma'] = df['close'].rolling(20).mean()
        {% endif %}
        {% endif %}

        {% if 'EMA' in entry.indicators_used %}
        # Exponential Moving Averages
        df['ema_fast'] = df['close'].ewm(span={{ entry_params.get('fast', 12) }}, adjust=False).mean()
        df['ema_slow'] = df['close'].ewm(span={{ entry_params.get('slow', 26) }}, adjust=False).mean()
        {% endif %}

        {% if 'MACD' in entry.indicators_used or (exit_condition and 'MACD' in exit_condition.indicators_used) %}
        # MACD
        ema12 = df['close'].ewm(span=12, adjust=False).mean()
        ema26 = df['close'].ewm(span=26, adjust=False).mean()
        df['macd'] = ema12 - ema26
        df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()
        {% endif %}

        {% if 'BB' in entry.indicators_used %}
        # Bollinger Bands
        df['bb_mid'] = df['close'].rolling(20).mean()
        df['bb_std'] = df['close'].rolling(20).std()
        df['bb_upper'] = df['bb_mid'] + 2 * df['bb_std']
        df['bb_lower'] = df['bb_mid'] - 2 * df['bb_std']
        {% endif %}

        {% if 'ATR' in entry.indicators_used or sl_config.sl_type == 'atr' or (tp_config and tp_config.tp_type == 'atr') %}
        # ATR
        high_low = df['high'] - df['low']
        high_close = (df['high'] - df['close'].shift()).abs()
        low_close = (df['low'] - df['close'].shift()).abs()
        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        df['atr'] = tr.rolling(14).mean()
        {% endif %}

        {% if 'STOCH' in entry.indicators_used %}
        # Stochastic
        low_min = df['low'].rolling(14).min()
        high_max = df['high'].rolling(14).max()
        df['stoch_k'] = 100 * (df['close'] - low_min) / (high_max - low_min + 1e-10)
        df['stoch_d'] = df['stoch_k'].rolling(3).mean()
        {% endif %}

        {% if 'CCI' in entry.indicators_used %}
        # CCI
        tp = (df['high'] + df['low'] + df['close']) / 3
        df['cci'] = (tp - tp.rolling(20).mean()) / (0.015 * tp.rolling(20).std())
        {% endif %}

        {% if 'ADX' in entry.indicators_used or (exit_condition and 'ADX' in exit_condition.indicators_used) %}
        # ADX
        high_diff = df['high'].diff()
        low_diff = -df['low'].diff()
        plus_dm = ((high_diff > low_diff) & (high_diff > 0)) * high_diff
        minus_dm = ((low_diff > high_diff) & (low_diff > 0)) * low_diff
        tr = (df['high'] - df['low']).rolling(14).mean()
        plus_di = 100 * plus_dm.rolling(14).mean() / (tr + 1e-10)
        minus_di = 100 * minus_dm.rolling(14).mean() / (tr + 1e-10)
        dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di + 1e-10)
        df['adx'] = dx.rolling(14).mean()
        {% endif %}

        {% if 'ROC' in entry.indicators_used or (exit_condition and 'ROC' in exit_condition.indicators_used) %}
        # Rate of Change
        df['roc'] = (df['close'] - df['close'].shift(10)) / df['close'].shift(10) * 100
        {% endif %}

        return df

    def generate_signal(self, df: pd.DataFrame, symbol: str = None) -> Signal | None:
        if len(df) < self.LOOKBACK + 10:
            return None

        # === ENTRY CONDITION: {{ entry.name }} ===
        {{ entry_logic | indent(8) }}

        {% for filter, filter_params, filter_logic in filters %}
        # Filter {{ loop.index }}: {{ filter.name }}
        {{ filter_logic | indent(8) }}
        entry_condition = entry_condition and filter_pass
        {% endfor %}

        if not entry_condition:
            return None

        # === BUILD SIGNAL ===
        # Use entry's direction (BIDI entries default to long)
        {% if entry.direction == 'BIDI' %}
        signal_direction = 'long'  # True BIDI entries default to long
        {% else %}
        signal_direction = '{{ entry.direction | lower }}'
        {% endif %}

        signal_kwargs = {
            'direction': signal_direction,
            'leverage': self.LEVERAGE,

            # Stop Loss (type-aware, optimized by typed parametric backtest)
            'sl_type': self.sl_type,
            'sl_pct': self.SL_PCT,
            {% if sl_config.sl_type == 'atr' %}
            'atr_stop_multiplier': self.atr_stop_multiplier,
            {% elif sl_config.sl_type == 'structure' %}
            # Calculate sl_price from lookback (swing low for long, swing high for short)
            {% if entry.direction == 'SHORT' %}
            'sl_price': df['high'].iloc[-self.structure_lookback:].max(),
            {% else %}
            'sl_price': df['low'].iloc[-self.structure_lookback:].min(),
            {% endif %}
            {% elif sl_config.sl_type == 'trailing' %}
            'trailing_stop_pct': self.trailing_stop_pct,
            'trailing_activation_pct': self.trailing_activation_pct,
            {% endif %}

            # Take Profit (type-aware, optimized by typed parametric backtest)
            'tp_type': self.tp_type,
            'tp_pct': self.TP_PCT,
            {% if tp_config and tp_config.tp_type == 'atr' %}
            'atr_take_multiplier': self.atr_take_multiplier,
            {% elif tp_config and tp_config.tp_type == 'rr_ratio' %}
            'rr_ratio': self.rr_ratio,
            {% endif %}

            # Time-based Exit (read from class attribute, may be 0 for no time exit)
            'exit_after_bars': self.exit_after_bars,

            'reason': '{{ entry.name }}{% if filters %} + {{ filters | length }} filters{% endif %}',
        }

        return Signal(**signal_kwargs)

    {% if exit_condition and exit_condition.category != 'time' and exit_logic %}
    def should_exit(self, df: pd.DataFrame, position_bars: int) -> bool:
        """
        Check dynamic exit conditions.
        Exit Mechanism: {{ exit_mechanism.name }} ({{ exit_mechanism.logic }})
        Exit Condition: {{ exit_condition.name }}
        """
        # Exit Condition: {{ exit_condition.name }}
        {{ exit_logic | indent(8) }}

        {% if exit_mechanism.logic == 'AND' %}
        # AND logic: exit only if both conditions met
        # (Trailing/TP checked by executor, we just check EC)
        return exit_signal
        {% else %}
        # OR logic: exit if exit_signal (TP/TS checked separately by executor)
        return exit_signal
        {% endif %}
    {% endif %}
